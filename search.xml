<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux</title>
    <url>/qyaaaa.github.io/2020/12/25/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><blockquote>
<p>修改主机名称</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname xxx</span><br><span class="line"># 之后重启服务器即可</span><br></pre></td></tr></table></figure>

<ul>
<li>top 常用的Linux性能分析命令，可以查看各个进程的资源占用状况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@qy ~]# top</span><br><span class="line">top - 16:08:11 up 22:03,  1 user,  load average: 0.16, 0.14, 0.14</span><br><span class="line">Tasks:  81 total,   1 running,  80 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  5.0 us,  1.0 sy,  0.0 ni, 94.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1882028 total,   856512 free,   481340 used,   544176 buff&#x2F;cache</span><br><span class="line">KiB Swap:  1049596 total,  1049596 free,        0 used.  1245716 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                     </span><br><span class="line"> 1364 root      10 -10  135660  16468  10244 S  4.0  0.9  37:30.98 AliYunDun                                   </span><br><span class="line">  465 root      20   0   17900   2080   1508 S  0.3  0.1   0:13.30 assist_daemon                               </span><br><span class="line">  871 root      20   0  574304  17428   6132 S  0.3  0.9   0:07.83 tuned                                       </span><br><span class="line">28010 root      20   0  161996   2164   1552 R  0.3  0.1   0:00.01 top                                         </span><br><span class="line">    1 root      20   0   51768   3928   2584 S  0.0  0.2   0:11.93 systemd                                     </span><br><span class="line">    2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd                                    </span><br><span class="line">    4 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker&#x2F;0:0H                                </span><br><span class="line">    5 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kworker&#x2F;u2:0                                </span><br><span class="line">    6 root      20   0       0      0      0 S  0.0  0.0   0:04.22 ksoftirqd&#x2F;0                                 </span><br><span class="line">    7 root      rt   0       0      0      0 S  0.0  0.0   0:00.00 migration&#x2F;0                                 </span><br><span class="line">    8 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcu_bh                                      </span><br><span class="line">    9 root      20   0       0      0      0 S  0.0  0.0   0:15.01 rcu_sched                                   </span><br><span class="line">   10 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 lru-add-drain                               </span><br><span class="line">   11 root      rt   0       0      0      0 S  0.0  0.0   0:00.31 watchdog&#x2F;0                                  </span><br><span class="line">   13 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kdevtmpfs</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>创建目录：<code>mkdir [参数] 目录名称</code></strong></p>
</li>
<li><p><strong>删除目录：<code>rmdir [选项] [目录]</code></strong></p>
</li>
<li><p><strong>创建文件：<code>touch 文件名称</code></strong></p>
</li>
<li><p><strong>复制：<code>cp [选项] 源文件 目标文件</code></strong></p>
</li>
</ul>
<ul>
<li><strong>rm移除文件或目录；mv移动文件或目录</strong></li>
</ul>
<ul>
<li><p><strong>通过进程id查找程序–ps</strong> :   <strong>ps -aux | grep pid</strong></p>
</li>
<li><p>**netstat ** :</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -ntlp   &#x2F;&#x2F;查看当前所有tcp端口·</span><br><span class="line">netstat -ntulp |grep 80   &#x2F;&#x2F;查看所有80端口使用情况·</span><br><span class="line">netstat -an | grep 3306   &#x2F;&#x2F;查看所有3306端口使用情况·</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cat从第一行正序显示内容；tac从最后一行开始显示内容；head -n20 显示前20行；tail看尾几行</strong></li>
</ul>
<ul>
<li><strong>ps -ef|grep redis 查看redis的进程信息</strong></li>
</ul>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/qyaaaa.github.io/2021/01/28/Nginx/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><blockquote>
<p><strong>学习自狂神说:<a href="https://www.bilibili.com/video/BV1jJ411S7xr">https://www.bilibili.com/video/BV1jJ411S7xr</a></strong></p>
</blockquote>
<h2 id="一、什们是Nginx？"><a href="#一、什们是Nginx？" class="headerlink" title="一、什们是Nginx？"></a>一、什们是Nginx？</h2><p><img src="https://i.loli.net/2021/01/28/7YkjDScy8XEiqUG.png" alt="Screenshot.png"></p>
<h2 id="二、Nginx作用？"><a href="#二、Nginx作用？" class="headerlink" title="二、Nginx作用？"></a>二、Nginx作用？</h2><p><img src="https://i.loli.net/2021/01/28/ADYrXzJw9jusEH3.png" alt="Screenshot1.png"></p>
<p><img src="https://i.loli.net/2021/01/28/xdDzgtaJOmZLqhT.png" alt="Screenshot.png"></p>
<p><img src="https://i.loli.net/2021/01/28/WtvsNb9QxhjgrUi.png" alt="Screenshot.png"></p>
<p><img src="https://i.loli.net/2021/01/28/vK8NJ4CBuPHa975.png" alt="Screenshot.png"></p>
<p>​     不建议用这种方式，用redis相对来说会更好！</p>
<p><img src="https://i.loli.net/2021/01/28/s9Or8MFApxDdbXi.png" alt="Screenshot.png"></p>
<p><img src="https://i.loli.net/2021/01/28/kYqcezMajQsCFSp.png" alt="Screenshot.png"></p>
<h2 id="三、Nginx的安装"><a href="#三、Nginx的安装" class="headerlink" title="三、Nginx的安装"></a>三、Nginx的安装</h2><p><img src="https://i.loli.net/2021/01/28/nxpCMkfKVmTd1gQ.png" alt="Screenshot.png"></p>
<p><strong>2、启动nginx</strong></p>
<p>有很多种方法启动nginx</p>
<p>(1)直接双击nginx.exe，双击后一个黑色的弹窗一闪而过</p>
<p>(2)打开cmd命令窗口，切换到nginx解压目录下，输入命令 <code>nginx.exe</code> ，回车即可</p>
<p><strong>3、检查nginx是否启动成功</strong></p>
<p>直接在浏览器地址栏输入网址 <a href="http://localhost/">http://localhost:80</a> 回车，出现以下页面说明启动成功！</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudya21688c8-159e-4caa-8e65-3dc056b6b78e.png" alt="img"></p>
<p><strong>4、配置监听</strong></p>
<p>nginx的配置文件是conf目录下的nginx.conf，默认配置的nginx监听的端口为80，如果80端口被占用可以修改为未被占用的端口即可。</p>
<p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/01/25/kuangstudyf23105c4-b0b2-4e22-a1bf-b8098f40c144.png" alt="img"></p>
<p>当我们修改了nginx的配置文件nginx.conf 时，不需要关闭nginx后重新启动nginx，只需要执行命令 <code>nginx -s reload</code> 即可让改动生效</p>
<p><strong>5、关闭nginx</strong></p>
<p>如果使用cmd命令窗口启动nginx， 关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx</p>
<p>(1)输入nginx命令 <code>nginx -s stop</code>(快速停止nginx) 或 <code>nginx -s quit</code>(完整有序的停止nginx)</p>
<p>(2)使用taskkill <code>taskkill /f /t /im nginx.exe</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">taskkill是用来终止进程的，&#x2F;f是强制终止 .&#x2F;t终止指定的进程和任何由此启动的子进程。&#x2F;im示指定的进程名称 .</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/02/04/oBUjn7HahLXPtEy.png" alt="Screenshot.png"></p>
<p><strong>5、下载安装包</strong></p>
<p>手动下载.tar.gz安装包，地址：<a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p>
<p>下载完毕上传到服务器上 /root</p>
<p><strong>6、解压</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0</span><br></pre></td></tr></table></figure>

<p><strong>7、配置</strong></p>
<p>使用默认配置，在nginx根目录下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configuremakemake install</span><br></pre></td></tr></table></figure>

<p>查找安装路径： <code>whereis nginx</code></p>
<h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;</span><br><span class="line">.&#x2F;nginx  启动</span><br><span class="line">.&#x2F;nginx -s stop  停止</span><br><span class="line">.&#x2F;nginx -s quit  安全退出</span><br><span class="line">.&#x2F;nginx -s reload  重新加载配置文件</span><br><span class="line">ps aux|grep nginx  查看nginx进程</span><br></pre></td></tr></table></figure>

<p><strong>学习自狂神说：</strong></p>
<p>视频地址：<a href="https://www.bilibili.com/video/BV1F5411J7vK?p=1">https://www.bilibili.com/video/BV1F5411J7vK?p=1</a></p>
<p>笔记地址：<a href="https://www.kuangstudy.com/bbs/1353634800149213186">https://www.kuangstudy.com/bbs/1353634800149213186</a></p>
]]></content>
      <categories>
        <category>中间件相关</category>
      </categories>
      <tags>
        <tag>中间件相关</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring框架导入</title>
    <url>/qyaaaa.github.io/2020/05/20/spring/</url>
    <content><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="一、常用依赖"><a href="#一、常用依赖" class="headerlink" title="一、常用依赖"></a>一、常用依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.18.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="二、注解说明"><a href="#二、注解说明" class="headerlink" title="二、注解说明"></a>二、注解说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.自动装箱</span><br><span class="line">@Autowired(required &#x3D; false) 自动装配通过类型名字</span><br><span class="line">@Qualifier(value &#x3D; &quot;dog1&quot;)</span><br><span class="line">@Resource 自动装配先通过类型名字，再通过类型</span><br><span class="line"></span><br><span class="line">2.@Component及其三个衍生注解（功能一致）</span><br><span class="line">@Component&#x2F;&#x2F;组件 等价于 &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.qy.pojo.User&quot;&#x2F;&gt;  用于pojo层</span><br><span class="line">web开发时使用mvc三层架构分层</span><br><span class="line">@Controller</span><br><span class="line">@Service</span><br><span class="line">@Repository 用于dao层</span><br><span class="line"></span><br><span class="line">3.单例模式与原型模式</span><br><span class="line">单例@Scope(&quot;singleton&quot;)</span><br><span class="line">原型@Scope(&quot;prototype&quot;)</span><br></pre></td></tr></table></figure>



<h2 id="三、配置信息"><a href="#三、配置信息" class="headerlink" title="三、配置信息"></a>三、配置信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">       xmlns:https&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--开启注解支持 --&gt;</span><br><span class="line">    &lt;context:annotation-config&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expression&#x3D;&quot;execution(* com.qy.service.UserServiceImpl.*(..))&quot;</span><br><span class="line">@Before(&quot;execution(* com.qy.service.UserServiceImpl.*(..))&quot;)</span><br></pre></td></tr></table></figure>



<h2 id="四、实现aop的三种方式"><a href="#四、实现aop的三种方式" class="headerlink" title="四、实现aop的三种方式"></a>四、实现aop的三种方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 注册bean--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;com.qy.service.UserServiceImpl&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;log&quot; class&#x3D;&quot;com.qy.log.Log&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;afterLog&quot; class&#x3D;&quot;com.qy.log.AfterLog&quot;&#x2F;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 方式1：使用原生的spring API接口--&gt;</span><br><span class="line">    &lt;!--配置aop:需要导入aop的约束 --&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--切入点 --&gt;</span><br><span class="line">        &lt;aop:pointcut id&#x3D;&quot;pointcut&quot; expression&#x3D;&quot;execution(* com.qy.service.UserServiceImpl.*(..))&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--执行环绕增强 --&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref&#x3D;&quot;log&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&#x2F;&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref&#x3D;&quot;afterLog&quot; pointcut-ref&#x3D;&quot;pointcut&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;aop:config&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- 方式2：自定义类--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;diy&quot; class&#x3D;&quot;com.qy.diy.DiyPointCut&quot;&#x2F;&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!-- 自定义切面，ref要引用的类--&gt;</span><br><span class="line">        &lt;aop:aspect ref&#x3D;&quot;diy&quot;&gt;</span><br><span class="line">            &lt;!--切入点 --&gt;</span><br><span class="line">            &lt;aop:pointcut id&#x3D;&quot;point&quot; expression&#x3D;&quot;execution(* com.qy.service.UserServiceImpl.*(..))&quot;&#x2F;&gt;</span><br><span class="line">            &lt;!--通知--&gt;</span><br><span class="line">            &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;</span><br><span class="line">            &lt;aop:after method&#x3D;&quot;after&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;aop:aspect&gt;</span><br><span class="line">    &lt;&#x2F;aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--方式3 --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;annotationPointCut&quot; class&#x3D;&quot;com.qy.diy.AnnotationPointCut&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 开启注解支持--&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy&#x2F;&gt;</span><br><span class="line">​&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>

<h2 id="五、spring整合mybatis"><a href="#五、spring整合mybatis" class="headerlink" title="五、spring整合mybatis"></a>五、spring整合mybatis</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.21&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--Spring操作数据库的话需要spring-jdbc包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.8.13&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>ssm相关</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令</title>
    <url>/qyaaaa.github.io/2020/10/10/git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="下载git"><a href="#下载git" class="headerlink" title="下载git"></a>下载git</h2><h2 id="配置公钥"><a href="#配置公钥" class="headerlink" title="配置公钥"></a>配置公钥</h2><h3 id="配置你的邮箱和用户名（github或gitee）："><a href="#配置你的邮箱和用户名（github或gitee）：" class="headerlink" title="配置你的邮箱和用户名（github或gitee）："></a><strong>配置你的邮箱和用户名（github或gitee）：</strong></h3><p>$ git config –global user.name “注册时账号的名字”</p>
<p>$ git config –global user.email “注册时使用的邮箱”</p>
<h3 id="获取ssh公钥："><a href="#获取ssh公钥：" class="headerlink" title="获取ssh公钥："></a><strong>获取ssh公钥：</strong></h3><p>ssh-keygen -t rsa -C “你注册时的邮箱号”</p>
<p>敲三次回车生成ssh公钥</p>
<h3 id="用一下命令查看"><a href="#用一下命令查看" class="headerlink" title="用一下命令查看:"></a><strong>用一下命令查看:</strong></h3><p>cat ~/.ssh/id_rsa.pub</p>
<p>将获取到的公钥粘贴到你的github或者gitee上的SSH公钥</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="直接上传到新创建的仓库"><a href="#直接上传到新创建的仓库" class="headerlink" title="直接上传到新创建的仓库"></a>直接上传到新创建的仓库</h3><p>git init   （初始化git仓库）</p>
<p>git remote add origin 项目地址</p>
<p>git add . 添加文件到缓存区（必须加点）</p>
<p>git commit -m “备注”（引号内填入你的备注）</p>
<p>git push origin master正式上传到github或gitee的你的仓库中。</p>
<p>git push origin master -f 强制推送，舍弃线上代码</p>
<h3 id="先clone在上传"><a href="#先clone在上传" class="headerlink" title="先clone在上传"></a>先clone在上传</h3><p>git add .</p>
<p>git status  (查看状态)</p>
<p>git commit -m “xxx”</p>
<p>git push origin master 正式上传到github或gitee的你的仓库中</p>
]]></content>
      <categories>
        <category>git相关</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot框架整合</title>
    <url>/qyaaaa.github.io/2020/07/26/springboot/</url>
    <content><![CDATA[<h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h1><blockquote>
<p>学习自狂神说:<a href="https://www.bilibili.com/video/BV19E411v7Ty">https://www.bilibili.com/video/BV19E411v7Ty</a></p>
</blockquote>
<h2 id="一、swagger"><a href="#一、swagger" class="headerlink" title="一、swagger"></a>一、swagger</h2><h3 id="1、集成swagger"><a href="#1、集成swagger" class="headerlink" title="1、集成swagger"></a>1、集成swagger</h3><ul>
<li>依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.qy.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2 &#x2F;&#x2F;开启swagger2</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<p><a href="http://localhost:8080/swagger-ui.html%EF%BC%883.0.0%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%EF%BC%89">http://localhost:8080/swagger-ui.html（3.0.0无法访问）</a></p>
<ul>
<li>示例</li>
</ul>
<p><img src="https://i.loli.net/2020/12/09/gAYJmDt97lOIBMQ.png" alt="1607483328_1_.png"></p>
<h3 id="2、配置swagger"><a href="#2、配置swagger" class="headerlink" title="2、配置swagger"></a>2、配置swagger</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.qy.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import springfox.documentation.service.ApiInfo;</span><br><span class="line">import springfox.documentation.service.Contact;</span><br><span class="line">import springfox.documentation.spi.DocumentationType;</span><br><span class="line">import springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line">import springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2 &#x2F;&#x2F;开启swagger2</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">    &#x2F;&#x2F;配置了Swagger的bean实例</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket docket()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;配置Swagger信息为ApiInfo</span><br><span class="line">    private ApiInfo apiInfo()&#123;</span><br><span class="line">        &#x2F;&#x2F;作者信息</span><br><span class="line">        Contact contact &#x3D; new Contact(&quot;qy&quot;,&quot;https:&#x2F;&#x2F;qyaa.gitee.io&#x2F;qyaa&#x2F;&quot;,&quot;qyxxxxxxx@gmail.com&quot;);</span><br><span class="line"></span><br><span class="line">        return new ApiInfo(&quot;qy的api文档&quot;,</span><br><span class="line">                &quot;Api Documentation&quot;,</span><br><span class="line">                &quot;1.0&quot;, &quot;urn:tos&quot;,</span><br><span class="line">                contact, &quot;Apache 2.0&quot;,</span><br><span class="line">                &quot;http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0&quot;,</span><br><span class="line">                 new ArrayList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、swagger配置扫描接口"><a href="#3、swagger配置扫描接口" class="headerlink" title="3、swagger配置扫描接口"></a>3、swagger配置扫描接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Docket docket()&#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                &#x2F;&#x2F;RequestHandlerSelectors:配置要扫描接口的方式</span><br><span class="line">                &#x2F;&#x2F;basePackage扫描指定的包</span><br><span class="line">                &#x2F;&#x2F;any扫描全部</span><br><span class="line">                &#x2F;&#x2F;none不扫描</span><br><span class="line">                &#x2F;&#x2F;withClassAnnotation扫描类上的注解</span><br><span class="line">                &#x2F;&#x2F;withMethodAnnotation扫描方法上的注解</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.qy.controller&quot;))</span><br><span class="line">                &#x2F;&#x2F;paths过滤什们路径</span><br><span class="line">                .paths(PathSelectors.ant(&quot;&#x2F;qy&#x2F;**&quot;))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、集成dubbo-zookeeper"><a href="#二、集成dubbo-zookeeper" class="headerlink" title="二、集成dubbo+zookeeper"></a>二、集成dubbo+zookeeper</h2><h3 id="1、依赖"><a href="#1、依赖" class="headerlink" title="1、依赖"></a>1、依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 导入 dubbo + zookeeper--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.sgroschupf&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zkclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- 引入zookeeper --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.12.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.12.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.14&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;!--排除这个slf4j-log4j12--&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Springboot相关</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架整合</title>
    <url>/qyaaaa.github.io/2020/05/26/ssm/</url>
    <content><![CDATA[<h2 id="一、回顾serlvet"><a href="#一、回顾serlvet" class="headerlink" title="一、回顾serlvet"></a>一、回顾serlvet</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 依赖--&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="二、过滤"><a href="#二、过滤" class="headerlink" title="二、过滤"></a>二、过滤</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;resources&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">                    &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">                &lt;&#x2F;includes&gt;</span><br><span class="line">                &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">            &lt;resource&gt;</span><br><span class="line">                &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">                &lt;includes&gt;</span><br><span class="line">                    &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">                    &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">                &lt;&#x2F;includes&gt;</span><br><span class="line">                &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">            &lt;&#x2F;resource&gt;</span><br><span class="line">        &lt;&#x2F;resources&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、web-xml"><a href="#三、web-xml" class="headerlink" title="三、web.xml"></a>三、web.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置DispatchServlet：这个springmvc的核心：请求分发器，前端控制器--&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">    &lt;!-- DispatchServlet要绑定Spring的配置文件--&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>



<h2 id="四、注解"><a href="#四、注解" class="headerlink" title="四、注解"></a>四、注解</h2><ul>
<li>1.使用注解方式配置springmvc-servlet.xml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">      xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">      xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span><br><span class="line">   &lt;context:component-scan base-package&#x3D;&quot;com.qy.controller&quot;&#x2F;&gt;</span><br><span class="line">   &lt;!-- 让Spring MVC不处理静态资源 --&gt;</span><br><span class="line">   &lt;mvc:default-servlet-handler &#x2F;&gt;</span><br><span class="line">   &lt;!--</span><br><span class="line">   支持mvc注解驱动</span><br><span class="line">       在spring中一般采用@RequestMapping注解来完成映射关系</span><br><span class="line">       要想使@RequestMapping注解生效</span><br><span class="line">       必须向上下文中注册DefaultAnnotationHandlerMapping</span><br><span class="line">       和一个AnnotationMethodHandlerAdapter实例</span><br><span class="line">       这两个实例分别在类级别和方法级别处理。</span><br><span class="line">       而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span><br><span class="line">    --&gt;</span><br><span class="line">   &lt;mvc:annotation-driven &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 视图解析器 --&gt;</span><br><span class="line">   &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span><br><span class="line">         id&#x3D;&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">       &lt;!-- 前缀 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">       &lt;!-- 后缀 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.普通方式配置springmvc-serlvet.xml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 处理器映射器--&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 处理器适配器--&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 视图解析器--&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id&#x3D;&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;!-- 前缀--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!-- 后缀--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;&#x2F;hello&quot; class&#x3D;&quot;com.qy.controller.HelloController&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h2 id="五、过滤器过滤乱码"><a href="#五、过滤器过滤乱码" class="headerlink" title="五、过滤器过滤乱码"></a>五、过滤器过滤乱码</h2><ul>
<li><strong>1.springmvc自带解决乱码</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;endoding&lt;&#x2F;filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line">    &lt;&#x2F;filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;endoding&lt;&#x2F;filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>2.json乱码解决</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--json乱码配置 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven&gt;</span><br><span class="line">   &lt;mvc:message-converters register-defaults&#x3D;&quot;true&quot;&gt;</span><br><span class="line">       &lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;</span><br><span class="line">           &lt;constructor-arg value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;bean&gt;</span><br><span class="line">       &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;</span><br><span class="line">           &lt;property name&#x3D;&quot;objectMapper&quot;&gt;</span><br><span class="line">               &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;</span><br><span class="line">                   &lt;property name&#x3D;&quot;failOnEmptyBeans&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">               &lt;&#x2F;bean&gt;</span><br><span class="line">           &lt;&#x2F;property&gt;</span><br><span class="line">       &lt;&#x2F;bean&gt;</span><br><span class="line">   &lt;&#x2F;mvc:message-converters&gt;</span><br><span class="line">&lt;&#x2F;mvc:annotation-driven&gt;</span><br></pre></td></tr></table></figure>

<h2 id="六、applicationContext-xml"><a href="#六、applicationContext-xml" class="headerlink" title="六、applicationContext.xml"></a>六、applicationContext.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;com.qy.controller&quot;&#x2F;&gt;</span><br><span class="line">	&lt;mvc:default-servlet-handler &#x2F;&gt;</span><br><span class="line">    &lt;mvc:annotation-driven &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 视图解析器 --&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span><br><span class="line">          id&#x3D;&quot;internalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;!-- 前缀 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- 后缀 --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h2 id="七、myabtis-mapper-xml"><a href="#七、myabtis-mapper-xml" class="headerlink" title="七、myabtis-mapper.xml"></a>七、myabtis-mapper.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.qy.mapper.UserMapper&quot;&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<h2 id="八、配置mybatis-config-xml"><a href="#八、配置mybatis-config-xml" class="headerlink" title="八、配置mybatis-config.xml"></a>八、配置mybatis-config.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<h2 id="九、数据库配置"><a href="#九、数据库配置" class="headerlink" title="九、数据库配置"></a>九、数据库配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db01?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;UTC</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ssm相关</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/qyaaaa.github.io/2021/01/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="1、二叉树的前序遍历（dfs）"><a href="#1、二叉树的前序遍历（dfs）" class="headerlink" title="1、二叉树的前序遍历（dfs）"></a>1、二叉树的前序遍历（dfs）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,list);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    private void dfs(TreeNode root,List&lt;Integer&gt; list)&#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        dfs(root.left,list);</span><br><span class="line">        dfs(root.right,list);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的前序遍历（bfs）"><a href="#二叉树的前序遍历（bfs）" class="headerlink" title="二叉树的前序遍历（bfs）"></a>二叉树的前序遍历（bfs）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode node &#x3D; root;</span><br><span class="line">        while (!stack.isEmpty() || node!&#x3D; null)&#123;</span><br><span class="line">            while (node !&#x3D; null)&#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node &#x3D; node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node &#x3D; stack.pop();</span><br><span class="line">            node &#x3D; node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、二叉树的中序遍历（dfs）"><a href="#2、二叉树的中序遍历（dfs）" class="headerlink" title="2、二叉树的中序遍历（dfs）"></a>2、二叉树的中序遍历（dfs）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,list);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root,List&lt;Integer&gt; list)&#123;</span><br><span class="line">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        dfs(root.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的中序遍历（bfs）"><a href="#二叉树的中序遍历（bfs）" class="headerlink" title="二叉树的中序遍历（bfs）"></a>二叉树的中序遍历（bfs）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode node &#x3D; root;</span><br><span class="line">        while (!stack.isEmpty() || node!&#x3D; null)&#123;</span><br><span class="line">            while (node !&#x3D; null)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node &#x3D; node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node &#x3D; stack.pop();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            node &#x3D; node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、二叉树的后序遍历（dfs）"><a href="#3、二叉树的后序遍历（dfs）" class="headerlink" title="3、二叉树的后序遍历（dfs）"></a>3、二叉树的后序遍历（dfs）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,list);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">    private void dfs(TreeNode root,List&lt;Integer&gt; list)&#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,list);</span><br><span class="line">        dfs(root.right,list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的后序遍历（bfs）"><a href="#二叉树的后序遍历（bfs）" class="headerlink" title="二叉树的后序遍历（bfs）"></a>二叉树的后序遍历（bfs）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (root &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode node &#x3D; root;</span><br><span class="line">        while (!stack.isEmpty() || node!&#x3D; null)&#123;</span><br><span class="line">            while (node !&#x3D; null)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                list.add(0,node.val);</span><br><span class="line">                node &#x3D; node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            node &#x3D; stack.pop();</span><br><span class="line">            node &#x3D; node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、二叉树的层序遍历（bfs）"><a href="#4、二叉树的层序遍历（bfs）" class="headerlink" title="4、二叉树的层序遍历（bfs）"></a>4、二叉树的层序遍历（bfs）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return new int[0];</span><br><span class="line">        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;&gt;()&#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node &#x3D; queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            if (node.left !&#x3D; null) queue.add(node.left);</span><br><span class="line">            if (node.right !&#x3D; null) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ints &#x3D; list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">        return ints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>二叉树相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/qyaaaa.github.io/2020/04/20/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p>
<p>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li>时间复杂度<ul>
<li>最好情况：O(n)</li>
<li>最坏情况：O(n2)</li>
<li>平均情况：O(n2)</li>
</ul>
</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BubbleSort &#123;</span><br><span class="line">    public static void bubbleSort(int[] arr) &#123;</span><br><span class="line">        &#x2F;&#x2F; 空数组 或 只有一个元素的数组，则什么都不做。</span><br><span class="line">        if (arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 1) return;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 外层循环表示趟数。</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 默认有序，如果发生交换说明无序。</span><br><span class="line">            boolean isSorted &#x3D; true;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; j 表示 要比较元素对的第一个。</span><br><span class="line">            for (int j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 不能写 &gt;&#x3D; ，否则不稳定。</span><br><span class="line">                if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                    int temp &#x3D; arr[j];</span><br><span class="line">                    arr[j] &#x3D; arr[j + 1];</span><br><span class="line">                    arr[j + 1] &#x3D; temp;</span><br><span class="line">                    &#x2F;&#x2F; 发生交换了，说明无序。</span><br><span class="line">                    isSorted &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 如果没有发生交换，则数组已经有序，结束冒泡。</span><br><span class="line">            if (isSorted)   return;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 把每一趟排序的结果也输出一下。</span><br><span class="line">            System.out.print(&quot;第 &quot;+ (i+1) + &quot; 趟: &quot;);</span><br><span class="line">            print(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;6, 9, 1, 4, 5, 8, 7, 0, 2, 3&#125;;</span><br><span class="line"> </span><br><span class="line">        System.out.print(&quot;排序前:  &quot;);</span><br><span class="line">        print(arr);</span><br><span class="line"> </span><br><span class="line">        bubbleSort(arr);</span><br><span class="line"> </span><br><span class="line">        System.out.print(&quot;排序后:  &quot;);</span><br><span class="line">        print(arr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 打印数组</span><br><span class="line">    public static void print(int[] arr) &#123;</span><br><span class="line">        if (arr &#x3D;&#x3D; null)    return;</span><br><span class="line"> </span><br><span class="line">        for(int i : arr) &#123;</span><br><span class="line">            System.out.print(i + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">排序前:  6 9 1 4 5 8 7 0 2 3 </span><br><span class="line">第 1 趟: 6 1 4 5 8 7 0 2 3 9 </span><br><span class="line">第 2 趟: 1 4 5 6 7 0 2 3 8 9 </span><br><span class="line">第 3 趟: 1 4 5 6 0 2 3 7 8 9 </span><br><span class="line">第 4 趟: 1 4 5 0 2 3 6 7 8 9 </span><br><span class="line">第 5 趟: 1 4 0 2 3 5 6 7 8 9 </span><br><span class="line">第 6 趟: 1 0 2 3 4 5 6 7 8 9 </span><br><span class="line">第 7 趟: 0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">排序后:  0 1 2 3 4 5 6 7 8 9</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/qyaaaa.github.io/2020/06/30/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Hungry &#123;</span><br><span class="line">    private static final Hungry hungry &#x3D; new Hungry();</span><br><span class="line">    private Hungry()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public static Hungry getInstance()&#123;</span><br><span class="line">        return hungry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="懒汉式-不安全"><a href="#懒汉式-不安全" class="headerlink" title="懒汉式(不安全)"></a>懒汉式(不安全)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Lazy &#123;</span><br><span class="line">    private static Lazy lazy;</span><br><span class="line">    private Lazy()&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Lazy getInstance()&#123;</span><br><span class="line">        if (lazy &#x3D;&#x3D; null)&#123;</span><br><span class="line">            lazy &#x3D; new Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        return lazy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                Lazy.getInstance();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="懒汉式（安全）"><a href="#懒汉式（安全）" class="headerlink" title="懒汉式（安全）"></a>懒汉式（安全）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> sychronized <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Lazy.getInstance();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双重检验单例模式"><a href="#双重检验单例模式" class="headerlink" title="双重检验单例模式"></a>双重检验单例模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双重单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Lazy lazy;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazy = <span class="keyword">new</span> Lazy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                Lazy.getInstance();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Holder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.HOLDER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Holder HOLDER = <span class="keyword">new</span> Holder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum EnumSingle &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public EnumSingle getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招面试</title>
    <url>/qyaaaa.github.io/2020/10/02/%E5%90%8C%E7%9B%BE%E7%A7%91%E6%8A%80%E5%88%9D%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p><strong>1、计算机网络的五层协议？</strong></p>
<p><strong>2、http的执行流程？</strong></p>
<ul>
<li><p>1.用户在浏览器中输入网址</p>
</li>
<li><p>2.浏览器拿到网址后通过dns，查询他的ip地址</p>
</li>
<li><p>3.dns服务器根据网址返回ip地址</p>
</li>
<li><p>4.浏览器得到地址后，和该地址建立一条通道（tcp连接）</p>
</li>
<li><p>5.浏览器向服务器发送一个请求，包含url，协议版本号（http1.0等），协议头（请求的方法get， 客户端cookie，agent信息头等等），协议内容等等</p>
</li>
<li><p>6.服务器拿到请求后，根据请求中的内容找相应的数据，如果不能正常拿到，返回一个错误码（例如404），如果能正常拿到，返回一堆内容（包括正常的状态吗，header头，例如是否压缩，是否分段传输等等。返回实体内容，例如页面的内容）</p>
</li>
<li><p>7.断开连接吗？一般情况下，服务器就关闭了tcp连接，但是如果有connection：keep-alive，则不关闭ctp，下次有请求的时候还会用同一个连接（http1.1）</p>
</li>
<li><p>8.浏览器拿到返回的数据，开始渲染html数据并展示给用户</p>
</li>
</ul>
<p><strong>3、线程池及线程池的一些参数？</strong></p>
<p><strong>4、sychronized和lock是怎么实现的？</strong></p>
<p><strong>5、HashMap的数据结构、扩容？</strong></p>
<p><strong>6、concurrentHashMap为什么是线程安全的？</strong></p>
<p><strong>7、list和set有什么不同？</strong></p>
<p><strong>8、数据库的事务？隔离级别？</strong></p>
<p><strong>9、数据库的索引</strong>(聚簇、非聚簇)</p>
<p><strong>10、redis中set和zet的不同？</strong></p>
<p><strong>11、跳表是怎么实现的？</strong></p>
]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/qyaaaa.github.io/2020/06/21/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><strong>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</strong></p>
<p><strong>1、 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p>
<p><strong>2、将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p>
<p>算法复杂度：O(nlogn)</p>
<blockquote>
<p>Java代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        int []arr &#x3D; &#123;7,6,7,11,5,12,3,0,1&#125;;</span><br><span class="line">        System.out.println(&quot;排序前：&quot;+Arrays.toString(arr));</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(&quot;排序前：&quot;+Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void sort(int []arr)&#123;</span><br><span class="line">        &#x2F;&#x2F;1.构建大顶堆</span><br><span class="line">        for(int i&#x3D;arr.length&#x2F;2-1;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            &#x2F;&#x2F;从第一个非叶子结点从下至上，从右至左调整结构</span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;2.调整堆结构+交换堆顶元素与末尾元素</span><br><span class="line">        for(int j&#x3D;arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">            swap(arr,0,j);&#x2F;&#x2F;将堆顶元素与末尾元素进行交换</span><br><span class="line">            adjustHeap(arr,0,j);&#x2F;&#x2F;重新对堆进行调整</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void adjustHeap(int []arr,int i,int length)&#123;</span><br><span class="line">        int temp &#x3D; arr[i];&#x2F;&#x2F;先取出当前元素i</span><br><span class="line">        for(int k&#x3D;i*2+1;k&lt;length;k&#x3D;k*2+1)&#123;&#x2F;&#x2F;从i结点的左子结点开始，也就是2i+1处开始</span><br><span class="line">            if(k+1&lt;length &amp;&amp; arr[k]&lt;arr[k+1])&#123;&#x2F;&#x2F;如果左子结点小于右子结点，k指向右子结点</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(arr[k] &gt;temp)&#123;&#x2F;&#x2F;如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span><br><span class="line">                arr[i] &#x3D; arr[k];</span><br><span class="line">                i &#x3D; k;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] &#x3D; temp;&#x2F;&#x2F;将temp值放到最终的位置</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 交换元素</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void swap(int []arr,int a ,int b)&#123;</span><br><span class="line">        int temp&#x3D;arr[a];</span><br><span class="line">        arr[a] &#x3D; arr[b];</span><br><span class="line">        arr[b] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">排序前：[7, 6, 7, 11, 5, 12, 3, 0, 1]</span><br><span class="line">排序前：[0, 1, 3, 5, 6, 7, 7, 11, 12]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招面试</title>
    <url>/qyaaaa.github.io/2020/10/20/%E5%AD%97%E8%8A%82%E5%AE%9E%E4%B9%A0%E7%94%9F%E5%87%89%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="2020秋招部分面试"><a href="#2020秋招部分面试" class="headerlink" title="2020秋招部分面试"></a>2020秋招部分面试</h2><h4 id="面六：（1h）"><a href="#面六：（1h）" class="headerlink" title="面六：（1h）"></a>面六：（1h）</h4><p><strong>1、Tomcat和Nginx的工作原理？</strong></p>
<p><strong>2、serlvet是线程安全的吗，serlvet的生命周期？</strong></p>
<p>不是。xxxx</p>
<ul>
<li><p>创建实例</p>
<ul>
<li>(由服务器创建 不需要用户去New),默认当请求第一次到达时创建对象,如果配置了<load-on-startup> 参数大于0 服务器启动时就会创建对象 并且创建的实例都是单例的</li>
</ul>
</li>
<li><p>初始化</p>
<ul>
<li>调用Servlet中的 init(ServletConfig config) 方法 服务器自动调用</li>
</ul>
</li>
<li><p>请求到达</p>
<ul>
<li>当请求到达时候调用service(ServletRequest req,ServletResponse resp)方法    (对于HttpServlet 提供了Service()方法 doGet()方法 和doPost()方法 而service()方法包括了这两个方法)</li>
</ul>
</li>
<li><p>当服务器销毁</p>
<ul>
<li>当服务器销毁servlet实例时 调用deStroy()方法 服务器自动调用</li>
</ul>
</li>
</ul>
<p><strong>3、如何设计实现HashMap的key和value？</strong></p>
<p><strong>4、如何设计实现ArrayList的add方法？</strong></p>
<p><strong>5、Mysql中两引擎的区别</strong>？</p>
<p><strong>6、什们时候使用索引？</strong></p>
<p><strong>7、说一下静态代理和动态代理？</strong></p>
<p><strong>8、Spring的AOC和IOP？</strong></p>
<p><strong>9、SpringMVC的运行流程？</strong></p>
<ul>
<li>spring mvc 先将请求发送给 DispatcherServlet。</li>
<li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li>
<li>DispatcherServlet 再把请求提交到对应的 Controller。</li>
<li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li>
<li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li>
<li>视图对象负责渲染返回给客户端。</li>
</ul>
<p><strong>10、DNS解析</strong></p>
<p><strong>11、使用Linux命令找到日志最频繁的top10，显示出时间 ？？（记不清）</strong></p>
<p><strong>12、算法：输入一个含有正整数、0、负整数的数组进行平方，打印出一组不包含重复值的数组并输出。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] ints1 &#x3D; &#123;-5, 1, 3, 6, 8&#125;;</span><br><span class="line">        int[] ints2 &#x3D; &#123;-5, 3, 7, 7, 8&#125;;</span><br><span class="line">        int[] sum &#x3D; sum(ints1, ints2);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; sum.length; i++) &#123;</span><br><span class="line">            System.out.print(sum[i] + &quot; &quot;);&#x2F;&#x2F;1 9 25 36 49 64</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int[] sum(int[] arr1,int[] arr2)&#123;</span><br><span class="line">        &#x2F;&#x2F;不考虑大数问题Integer.MAX_VALUE</span><br><span class="line">        HashSet&lt;Integer&gt; integers &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            int s &#x3D; arr1[i] * arr1[i];</span><br><span class="line">            integers.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arr2.length; i++) &#123;</span><br><span class="line">            int s &#x3D; arr2[i] * arr2[i];</span><br><span class="line">            integers.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;方法1</span><br><span class="line">        int[] ints &#x3D; integers.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">        &#x2F;&#x2F;方法2</span><br><span class="line">&#x2F;&#x2F;        Object[] objects &#x3D; integers.toArray();</span><br><span class="line">&#x2F;&#x2F;        int[] ints &#x3D; new int[objects.length];</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; objects.length; i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            ints[i] &#x3D; (int)objects[i];</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">        Arrays.sort(ints);</span><br><span class="line">        return ints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招面试</title>
    <url>/qyaaaa.github.io/2020/09/30/%E5%B0%8F%E9%B1%BC%E6%98%93%E8%BF%9E%E5%87%89%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="2020秋招部分面试："><a href="#2020秋招部分面试：" class="headerlink" title="2020秋招部分面试："></a>2020秋招部分面试：</h2><h4 id="面五：（40min）"><a href="#面五：（40min）" class="headerlink" title="面五：（40min）"></a>面五：（40min）</h4><p><strong>1、手写快速排序，详见算法篇。</strong></p>
<p><strong>2、手写双重校验的单例模式。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;jvm类加载机制，静态变量加载方法区，线程公共的</span><br><span class="line">    &#x2F;&#x2F;volatile关键字来保证可见性、有序性写操作先行发生于后面对这个变量的读操作</span><br><span class="line">    private volatile static Singleton singleton;</span><br><span class="line"> </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;只初始化一次</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (singleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;多线程并发解决保证原子性</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (singleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    singleton &#x3D; new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、HashMap的实现原理、哈希算法、红黑树的构成、红节点黑节点分别存储什们？</strong></p>
<p><strong>4、说一下创建线程池及其参数？</strong></p>
<p><strong>5、说一下Java的内存模型？</strong></p>
<p><strong>6、说一下双亲委托模型？</strong></p>
<ul>
<li>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</li>
</ul>
<p><strong>7、能否继承String类（final）？</strong></p>
<p><strong>8、ConcurrentHashMap如何实现线程安全？</strong></p>
<p><strong>9、说一下乐观锁和悲观锁。</strong></p>
<ul>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>
<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放</li>
</ul>
<p><strong>10、什们是死锁？</strong></p>
<ul>
<li><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<p><strong>如何防止死锁？</strong></p>
</li>
</ul>
<ul>
<li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li>
<li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li>
<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>
<li>尽量减少同步的代码块。</li>
</ul>
<p><strong>11、说一下http协议</strong></p>
<p><strong>12、gc回收机制是什么</strong></p>
]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>寒窑赋</title>
    <url>/qyaaaa.github.io/2020/10/20/%E5%AF%92%E7%AA%91%E8%B5%8B/</url>
    <content><![CDATA[<p><strong>天有不测风云，人有旦夕祸福。</strong></p>
<p><strong>蜈蚣百足，行不及蛇；雄鸡扇翼，飞不过鸦。</strong></p>
<p><strong>马有千里之程，无骑不能自往；人有冲天之志，非运不能腾达。</strong></p>
<p><strong>文章盖世，孔子厄困于陈邦；武略超群，太公垂钓于渭水。</strong></p>
<p><strong>颜渊命短，实非凶恶之徒；盗跖年长，不是善良之辈。</strong></p>
<p><strong>尧舜明圣，却生不肖之儿；瞽叟愚顽，反生大孝之子。</strong></p>
<p><strong>张良原是布衣，萧何曾为县吏；韩信未遇之时，无一日之餐，及至遇行，腰悬三齐玉印。</strong></p>
<p><strong>楚霸英雄，败于乌江自刎；汉王柔弱，竟有万里江山。</strong></p>
<p><strong>晏子身短五尺，使楚拜齐名相；诸葛力无缚鸡，出作蜀汉军师。</strong></p>
<p><strong>李广有射虎之威，到老无封；冯夷有乘龙之才，一生不遇。</strong></p>
<p><strong>满腹文章，白发竟然不中；才疏学浅，少年及第登科。</strong></p>
<p><strong>深院宫娥，运退反为妓女；风流妓女，时来配作夫人。</strong></p>
<p><strong>青春美女，却招愚蠢之夫；俊秀郎君，反配粗丑之妇。</strong></p>
<p><strong>蛟龙未遇，潜水于鱼鳖之间；君子失时，拱手于小人之下。</strong></p>
<p><strong>天不得时，日月无光；地不得时，草木不生；</strong></p>
<p><strong>水不得时，波浪不静；人不得时，限运不通。</strong></p>
<p><strong>人生在世，富贵不能淫，贫贱不能移。有先贫而后富，有老壮而少衰。</strong></p>
<p><strong>衣服虽破，常有礼仪之容；面带忧愁，每抱怀安之量。</strong></p>
<p><strong>时遭不遇，只宜安贫守份；心若不欺，必有扬眉之日。</strong></p>
<p><strong>初贫君子，天然骨格生成；乍富小人，不脱贫寒肌体。</strong></p>
<p><strong>福禄岂能强求，富贵谁人不欲。</strong></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/qyaaaa.github.io/2020/06/30/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并算法的理解比较难，是一种区别于插入算法，选择算法和交换算法的一种独特算法，需要逐步理解。<br><strong>核心思想：归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</strong></p>
<p>（1）稳定性</p>
<ul>
<li>归并排序是一种稳定的排序。</li>
</ul>
<p>（2）存储结构要求</p>
<ul>
<li>可用顺序存储结构。也易于在链表上实现。</li>
</ul>
<p>（3）时间复杂度</p>
<ul>
<li>对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。</li>
</ul>
<p>（4）空间复杂度<br>　 <strong>需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序</strong></p>
<p>​     <strong>注意：若用单链表做存储结构，很容易给出就地的归并排序</strong></p>
<blockquote>
<p>归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。</p>
</blockquote>
<p><strong>算法实现代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc &#x3D; new Scanner(System.in);</span><br><span class="line">        int []data  &#x3D; new int[8];</span><br><span class="line">        for(int i&#x3D; 0;i&lt;data.length ;i++)&#123;</span><br><span class="line">            data[i] &#x3D; sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;归并排序</span><br><span class="line">        mergeSort(data ,0 ,data.length-1);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0;i&lt;data.length ;i++)&#123;</span><br><span class="line">            System.out.print(data[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;归并排序</span><br><span class="line">    public static int[] mergeSort(int[] data,int low,int high)&#123;</span><br><span class="line">        int mid &#x3D; (low+high)&#x2F;2;</span><br><span class="line">        if(low&lt;high)&#123;</span><br><span class="line">            mergeSort(data,low,mid);</span><br><span class="line">            mergeSort(data,mid+1,high);</span><br><span class="line">            &#x2F;&#x2F;左右归并</span><br><span class="line">            merge(data,low,mid,high);</span><br><span class="line">        &#125;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;归并排序的辅助方法</span><br><span class="line">    public static void merge(int[] data, int low, int mid, int high) &#123;</span><br><span class="line">        int[] temp &#x3D; new int[high-low+1];</span><br><span class="line">        int i &#x3D; low;</span><br><span class="line">        int j &#x3D; mid+1;</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 把较小的数先移到新数组中</span><br><span class="line">        while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;high)&#123;</span><br><span class="line">            if(data[i]&lt;data[j])&#123;</span><br><span class="line">                temp[k++] &#x3D; data[i++];</span><br><span class="line">                &#x2F;&#x2F;说明：temp[k++] &#x3D; temp[k] ,只是在temp[k++]之后k的值加1</span><br><span class="line">                &#x2F;&#x2F;说明：temp[++k] &#x3D; temp[k+1],temp[++k]之后k的值加1</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp[k++] &#x3D; data[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把左边剩余的数移入数组</span><br><span class="line">        while(i&lt;&#x3D;mid)&#123;</span><br><span class="line">            temp[k++] &#x3D; data[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把右边边剩余的数移入数组</span><br><span class="line">        while(j&lt;&#x3D;high)&#123;</span><br><span class="line">            temp[k++] &#x3D; data[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把新数组中的数覆盖nums数组</span><br><span class="line">        for(int x&#x3D;0;x&lt;temp.length;x++)&#123;</span><br><span class="line">            data[x+low] &#x3D; temp[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/qyaaaa.github.io/2020/04/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li>时间复杂度<ul>
<li>最好情况：O(nlogn)</li>
<li>最坏情况：O(n2)</li>
<li>平均情况：O(nlogn)</li>
</ul>
</li>
<li>空间复杂度： O(logn) （栈占用的空间）</li>
<li>稳定性： 不稳定</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class QuickSort &#123;</span><br><span class="line">    public static void quickSort(int[] arr) &#123;</span><br><span class="line">        if (arr &#x3D;&#x3D; null || arr.length &lt;&#x3D; 1) return;</span><br><span class="line">        &#x2F;&#x2F; 包左不包右</span><br><span class="line">        quickSort(arr, 0, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void quickSort(int[] arr, int low, int high) &#123;</span><br><span class="line">        &#x2F;&#x2F; 只有一个元素的话，则什么都不做。</span><br><span class="line">        if (high - low &lt;&#x3D; 1)    return;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 分区。</span><br><span class="line">        int partition &#x3D; partition(arr, low, high);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 递归左右两个分区。</span><br><span class="line">        quickSort(arr, low, partition);</span><br><span class="line">        quickSort(arr, partition + 1, high);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static int partition(int[] arr, int low, int high) &#123;</span><br><span class="line">        int pivot &#x3D; arr[low];   &#x2F;&#x2F; 基准值是第一个元素。</span><br><span class="line">        int left &#x3D; low; &#x2F;&#x2F; 左指针指向最左侧。</span><br><span class="line">        int right &#x3D; high - 1;   &#x2F;&#x2F; 右指针指向最右侧。</span><br><span class="line"> </span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            &#x2F;&#x2F; 若右指针大于基准值，则左移。</span><br><span class="line">            while (left &lt; right &amp;&amp; arr[right] &gt;&#x3D; pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[left] &#x3D; arr[right]; &#x2F;&#x2F; 直到arr[right]小于基准值，放到左边。</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 若左指针小于基准值，则右移。</span><br><span class="line">            while (left &lt; right &amp;&amp; arr[left] &lt;&#x3D; pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[right] &#x3D; arr[left]; &#x2F;&#x2F; 直到arr[left]大于基准值，放到右边。</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 基准值放到正确位置。</span><br><span class="line">        arr[left] &#x3D; pivot;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 把每一趟排序的结果也输出一下。</span><br><span class="line">        print(arr);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 返回基准值的索引。</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] arr &#x3D; &#123;6, 9, 1, 4, 5, 8, 7, 0, 2, 3&#125;;</span><br><span class="line"> </span><br><span class="line">        System.out.print(&quot;排序前:  &quot;);</span><br><span class="line">        print(arr);</span><br><span class="line"> </span><br><span class="line">        quickSort(arr);</span><br><span class="line"> </span><br><span class="line">        System.out.print(&quot;排序后:  &quot;);</span><br><span class="line">        print(arr);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 打印数组</span><br><span class="line">    public static void print(int[] arr) &#123;</span><br><span class="line">        if (arr &#x3D;&#x3D; null)    return;</span><br><span class="line"> </span><br><span class="line">        for(int i : arr) &#123;</span><br><span class="line">            System.out.print(i + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">排序前:  6 9 1 4 5 8 7 0 2 3 </span><br><span class="line">3 2 1 4 5 0 6 7 8 9 </span><br><span class="line">0 2 1 3 5 4 6 7 8 9 </span><br><span class="line">0 2 1 3 5 4 6 7 8 9 </span><br><span class="line">0 1 2 3 5 4 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">排序后:  0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/qyaaaa.github.io/2020/04/26/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。</span><br></pre></td></tr></table></figure>

<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a><strong>直接插入排序</strong></h2><p>直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void StraightInsertSort(int[] a) &#123;</span><br><span class="line">        int temp &#x3D; 0,j &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 1;i &lt; a.length;i++)&#123;</span><br><span class="line">            temp &#x3D; a[i];</span><br><span class="line">            j &#x3D; i;</span><br><span class="line">            while(j &gt; 0 &amp;&amp; a[j-1] &gt;&#x3D; temp)&#123;</span><br><span class="line">                a[j] &#x3D; a[j-1];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a><strong>二分插入排序</strong></h2><p>将直接插入排序中寻找A[i]的插入位置的方法改为采用折半比较，即可得到折半插入排序算法。在处理A[i]时，A[0]……A[i-1]已经按关键码值排好序。所谓折半比较，就是在插入A[i]时，取A[i-1/2]的关键码值与A[i]的关键码值进行比较，如果A[i]的关键码值小于A[i-1/2]的关键码值，则说明A[i]只能插入A[0]到A[i-1/2]之间，故可以在A[0]到A[i-1/2-1]之间继续使用折半比较；否则只能插入A[i-1/2]到A[i-1]之间，故可以在A[i-1/2+1]到A[i-1]之间继续使用折半比较。如此担负，直到最后能够确定插入的位置为止。一般在A[k]和A[r]之间采用折半，其中间结点为A[k+r/2]，经过一次比较即可排除一半记录，把可能插入的区间减小了一半，故称为折半。执行折半插入排序的前提是文件记录必须按顺序存储。</p>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void binaryInsertSort(int array[],int size)  </span><br><span class="line">    &#123;  </span><br><span class="line">        int i,j,k,temp;  </span><br><span class="line">        for(i&#x3D;1;i&lt;size;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            temp&#x3D;array[i];  </span><br><span class="line">            if(array[i]&lt;array[0])  </span><br><span class="line">                k&#x3D;0;  </span><br><span class="line">            else  </span><br><span class="line">                k &#x3D; binarySearch(array,0,i,temp);  </span><br><span class="line"></span><br><span class="line">            for(j&#x3D;i;j&gt;k;j--)  </span><br><span class="line">            &#123;  </span><br><span class="line">                array[j]&#x3D;array[j-1];  </span><br><span class="line">            &#125;  </span><br><span class="line">            array[k]&#x3D;temp;  </span><br><span class="line">            System.out.println(Arrays.toString(array));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><strong>希尔排序</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminshing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。</span><br><span class="line">希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</span><br></pre></td></tr></table></figure>

<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void sort(int[] a) &#123;</span><br><span class="line">        int h &#x3D; 1;</span><br><span class="line">        while (h &lt; a.length &#x2F; 3) &#123;</span><br><span class="line">            h &#x3D; h * 3 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int temp &#x3D; 0, j &#x3D; 0;</span><br><span class="line">        while (h &gt;&#x3D; 1) &#123;</span><br><span class="line">            for (int i &#x3D; h; i &lt; a.length; i++) &#123;</span><br><span class="line">                temp &#x3D; a[i];</span><br><span class="line">                for (j &#x3D; i; j &gt;&#x3D; h &amp;&amp; a[j - h] &gt;&#x3D; temp; j -&#x3D; h) &#123;</span><br><span class="line">                    a[j] &#x3D; a[j - h];</span><br><span class="line">                &#125;</span><br><span class="line">                a[j] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">            h &#x3D; (h - 1) &#x2F; 3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>我的博客</title>
    <url>/qyaaaa.github.io/2020/04/20/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="我的博客"><a href="#我的博客" class="headerlink" title="我的博客"></a>我的博客</h1><p><strong>为了记录自己的学习经历、复习经历、面试经历、日常生活而创建！</strong></p>
<p><strong>创建时间：</strong>创建于2020-04-20</p>
<p><strong>框架：</strong>使用hexo+next主题+node.js,并利用gitee来搭建</p>
<p><strong>内嵌</strong>：内嵌百度统计</p>
<p><strong>评论功能</strong>：用Valine来实现</p>
<p><strong>运行时间</strong>：添加网站运行时间</p>
<p><strong>浏览量</strong>：2020-9-30实现</p>
<p><strong>搜素功能</strong>：2020-10-20实现 </p>
<ul>
<li>  <strong>安装exo-generator-searchdb这个插件</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p><strong>阅读全文：</strong>2020-11-02实现</p>
<p><strong>分享功能</strong>：2020-11-11实现</p>
<p><strong>字数统计</strong>：2021-3-2添加</p>
<p><strong>阅读时长：</strong>2021-3-2添加</p>
<ul>
<li><strong>安装 hexo-wordcount 插件</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>MyBlog</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招面试</title>
    <url>/qyaaaa.github.io/2020/10/18/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%8D%8E/</url>
    <content><![CDATA[<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><p><strong>1、Map的遍历方式？</strong></p>
<p><strong>2、ArrayList和LinkedList的区别？</strong></p>
<p><strong>3、Collection和Collections的区别？</strong></p>
<p><strong>4、ConcurrentHashMap实现线程安全的方式？</strong></p>
<p><strong>5、Mysql如何添加一个字段？</strong></p>
<blockquote>
<p>ALTER table tab_xxx add xxx_num int(5) not Null DEFAULT ‘0’ COMMENT ‘xxxx’;<br>ALTER table tab_xxx ADD xxx_id bigint(20) NOT NULL COMMENT ‘xxxID’;<br>ALTER table tab_xxx ADD xxx_name varchar(20) NOT NULL COMMENT ‘xxx名称’;</p>
</blockquote>
<p><strong>6、Mysql分页（limit）？</strong></p>
<blockquote>
<p>例如：对product表进行分页查询：</p>
<p>SELECT * FROM product LIMIT 0,3;</p>
</blockquote>
<p><strong>7、Redis的数据类型？</strong></p>
<p><strong>8、Redis的持久化方式？</strong></p>
<p><strong>9、Jvm的内存模型？</strong></p>
<p><strong>10、如何使线程安全？</strong></p>
<p><strong>11、mybatis如何装配属性？</strong></p>
]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/qyaaaa.github.io/2021/01/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><blockquote>
<p>常见的数据结构：</p>
</blockquote>
<p><img src="https://i.loli.net/2021/01/18/UCQRnSJdkrtzlc6.png" alt="Screenshot.png"></p>
<blockquote>
<p>常见的算法：</p>
</blockquote>
<h2 id="①分治算法："><a href="#①分治算法：" class="headerlink" title="①分治算法："></a><strong>①分治算法：</strong></h2><ul>
<li><p>1.把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
</li>
<li><p>2.分治策略是对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。</p>
<ul>
<li><p>适用情况</p>
<p>1)该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>2)该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
<p>3)利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<ol start="4">
<li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</li>
</ol>
</li>
</ul>
</li>
<li><p>分治法的复杂性分析</p>
<p>一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</p>
<p>​    T（n）= k T(n/m)+f(n)</p>
<p>通过迭代法求得方程的解：</p>
<p>递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当          mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。</p>
</li>
<li><p>分治法例题：合并排序和快速排序</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class 分治_合并排序 &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 函数说明：在数组被拆分以后进行合并</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	static void Merge(int a[], int left, int middle, int rigth) &#123;</span><br><span class="line">		&#x2F;&#x2F;定义左端数组大小</span><br><span class="line">		int n1 &#x3D; middle - left+1;</span><br><span class="line">		int n2 &#x3D; rigth - middle;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;初始化数组，分配内存</span><br><span class="line">		int bejin[] &#x3D; new int[n1];</span><br><span class="line">		int end[] &#x3D; new int[n2];</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;数组赋值</span><br><span class="line">		for(int i &#x3D; 0; i &lt; n1; i++)</span><br><span class="line">			bejin[i] &#x3D; a[left + i];</span><br><span class="line">			</span><br><span class="line">		for(int i &#x3D; 0; i &lt; n2; i++) </span><br><span class="line">			end[i] &#x3D; a[middle+1+i];</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;用key做原数组索引，没调用一次函数重新给原数组付一次值</span><br><span class="line">		int i &#x3D; 0, j &#x3D; 0, key;</span><br><span class="line">		for(key &#x3D; left; key &lt;&#x3D; rigth; key++)&#123;</span><br><span class="line">			</span><br><span class="line">			if(n1&gt;i&amp;&amp;n2&gt;j&amp;&amp;i &lt; n1 &amp;&amp; bejin[i] &lt;&#x3D; end[j])</span><br><span class="line">				a[key] &#x3D; bejin[i++];</span><br><span class="line">			else if(n1&gt;i&amp;&amp;n2&gt;j&amp;&amp;j &lt; n2 &amp;&amp; bejin[i] &gt;&#x3D; end[j])</span><br><span class="line">				a[key] &#x3D; end[j++];	</span><br><span class="line">			else if(i &#x3D;&#x3D; n1 &amp;&amp; j &lt; n2)</span><br><span class="line">				a[key] &#x3D; end[j++];</span><br><span class="line">			else if(j &#x3D;&#x3D; n2 &amp;&amp; i &lt; n1)</span><br><span class="line">				a[key] &#x3D; bejin[i++];	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 差分数组区间，不断分支</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	static void MergeSort(int a[],int left,int rigth) &#123;</span><br><span class="line">		int middle&#x3D;0;</span><br><span class="line">		if(left&lt;rigth) &#123;</span><br><span class="line">			middle &#x3D;(rigth+left)&#x2F;2;</span><br><span class="line">			MergeSort(a, left, middle);</span><br><span class="line">			MergeSort(a, middle+1, rigth);</span><br><span class="line">			Merge(a, left, middle, rigth);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int a[]&#x3D; &#123;85,3,52,9,7,1,5,4&#125;;</span><br><span class="line">		MergeSort(a, 0,7); </span><br><span class="line">		for(int i&#x3D;0;i&lt;8;i++) &#123;</span><br><span class="line">			System.out.print(&quot; &quot;+a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="②贪心算法："><a href="#②贪心算法：" class="headerlink" title="②贪心算法："></a>②贪心算法：</h2><ul>
<li><p>一、基本概念</p>
<ul>
<li><p>所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p>
</li>
<li><p>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
</li>
<li><p>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p>
</li>
</ul>
</li>
<li><p>二、贪心算法的基本思路：</p>
<ul>
<li><p>1.建立数学模型来描述问题。</p>
</li>
<li><p>2.把求解的问题分成若干个子问题。</p>
</li>
<li><p>3.对每一子问题求解，得到子问题的局部最优解。</p>
</li>
<li><p>4.把子问题的解局部最优解合成原来解问题的一个解。</p>
</li>
</ul>
</li>
<li><p>三、贪心算法适用的问题</p>
<ul>
<li><p>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</p>
</li>
<li><p>实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p>
</li>
</ul>
</li>
<li><p>四、贪心算法的实现框架</p>
<ul>
<li><p>从问题的某一初始解出发；</p>
</li>
<li><p>while （能朝给定总目标前进一步）</p>
</li>
<li><p>{ </p>
</li>
<li><p>利用可行的决策，求出可行解的一个解元素；</p>
</li>
<li><p>}</p>
</li>
<li><p>由所有解元素组合成问题的一个可行解； </p>
</li>
</ul>
</li>
<li><p>五、贪心策略的选择</p>
<ul>
<li>因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</li>
</ul>
</li>
<li><p>贪心策略例题：prim算法</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class 贪心算法_prim算法 &#123;</span><br><span class="line">	static int MAX &#x3D; Integer.MAX_VALUE;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;定义无向图矩阵</span><br><span class="line">		int[][] map &#x3D; new int[][] &#123;</span><br><span class="line">				&#123; 0, 1, 6, 2&#125;,</span><br><span class="line">				&#123; 1, 0, 3, 2&#125;,</span><br><span class="line">				&#123; 6, 3, 0, 1&#125;,</span><br><span class="line">				&#123; 2, 2, 1, 0&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">		prim(map, map.length);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void prim(int[][] graph, int n)&#123;</span><br><span class="line">			&#x2F;&#x2F;定义节点名字</span><br><span class="line">	        char[] c &#x3D; new char[]&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;&#125;;        </span><br><span class="line">	        int[] lowcost &#x3D; new int[n];  &#x2F;&#x2F;到新集合的最小权 </span><br><span class="line">	        int[] mid&#x3D; new int[n];&#x2F;&#x2F;存取前驱结点</span><br><span class="line">            List&lt;Character&gt; list&#x3D;new ArrayList&lt;Character&gt;();&#x2F;&#x2F;用来存储加入结点的顺序</span><br><span class="line">	        int i, j, min, minid , sum &#x3D; 0;</span><br><span class="line">	        &#x2F;&#x2F;初始化辅助数组</span><br><span class="line">	        for(i&#x3D;1;i&lt;n;i++)</span><br><span class="line">	        &#123;</span><br><span class="line">	        	lowcost[i]&#x3D;graph[0][i];</span><br><span class="line">	        	mid[i]&#x3D;0;</span><br><span class="line">	        &#125;</span><br><span class="line">	        list.add(c[0]);</span><br><span class="line">            &#x2F;&#x2F;一共需要加入n-1个点</span><br><span class="line">	        for(i&#x3D;1;i&lt;n;i++)</span><br><span class="line">	        &#123;</span><br><span class="line">	        	 min&#x3D;MAX;</span><br><span class="line">	        	 minid&#x3D;0;</span><br><span class="line">	        	 &#x2F;&#x2F;每次找到距离集合最近的点</span><br><span class="line">	        	 for(j&#x3D;1;j&lt;n;j++)</span><br><span class="line">	        	 &#123;</span><br><span class="line">	        		 if(lowcost[j]!&#x3D;0&amp;&amp;lowcost[j]&lt;min)</span><br><span class="line">	        		 &#123;</span><br><span class="line">	        			 min&#x3D;lowcost[j];</span><br><span class="line">	        			 minid&#x3D;j;</span><br><span class="line">	        		 &#125;</span><br><span class="line">	        	 &#125;</span><br><span class="line">	        	 if(minid&#x3D;&#x3D;0) return;</span><br><span class="line">	        	 list.add(c[minid]);</span><br><span class="line">	        	 lowcost[minid]&#x3D;0;</span><br><span class="line">	        	 sum+&#x3D;min;</span><br><span class="line">	        	 System.out.println(c[mid[minid]] + &quot;到&quot; + c[minid] + &quot; 权值：&quot; + min);</span><br><span class="line">	        	 &#x2F;&#x2F;加入该点后，更新其它点到集合的距离</span><br><span class="line">	        	 for(j&#x3D;1;j&lt;n;j++)</span><br><span class="line">	        	 &#123;</span><br><span class="line">	        		 if(lowcost[j]!&#x3D;0&amp;&amp;lowcost[j]&gt;graph[minid][j])</span><br><span class="line">	        		 &#123;</span><br><span class="line">	        			 lowcost[j]&#x3D;graph[minid][j];</span><br><span class="line">	        			 mid[j]&#x3D;minid;	 </span><br><span class="line">	        		 &#125;</span><br><span class="line">	        	 &#125;</span><br><span class="line">	        	 System.out.print(&quot;\n&quot;);</span><br><span class="line">	        &#125;</span><br><span class="line">	        System.out.println(&quot;sum:&quot; + sum);</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="③动态规划："><a href="#③动态规划：" class="headerlink" title="③动态规划："></a>③动态规划：</h2><ul>
<li><p>一、基本概念</p>
<ul>
<li>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</li>
</ul>
</li>
<li><p>二、基本思想与策略</p>
<ul>
<li><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p>
</li>
<li><p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
</li>
<li><p>与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
</li>
</ul>
</li>
<li><p>三、适用的情况</p>
<ul>
<li><p>能采用动态规划求解的问题的一般要具有3个性质：</p>
</li>
<li><p>(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
</li>
<li><p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
</li>
<li><p>(3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
</li>
</ul>
</li>
</ul>
<h2 id="④回溯算法："><a href="#④回溯算法：" class="headerlink" title="④回溯算法："></a>④回溯算法：</h2><ul>
<li><p>1、概念</p>
<ul>
<li><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
</li>
<li><p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
</li>
<li><p>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
</li>
</ul>
</li>
<li><p>2、基本思想</p>
<ul>
<li><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
</li>
<li><p>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
</li>
<li><p>而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
</li>
</ul>
</li>
<li><p>3、用回溯法解题的一般步骤：</p>
<ul>
<li><p>（1）针对所给问题，确定问题的解空间：</p>
</li>
<li><p>首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p>
</li>
<li><p>（2）确定结点的扩展搜索规则</p>
</li>
<li><p>（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p>
</li>
</ul>
</li>
</ul>
<h2 id="⑤分支限界法："><a href="#⑤分支限界法：" class="headerlink" title="⑤分支限界法："></a>⑤分支限界法：</h2><ul>
<li><p>一、基本描述</p>
<ul>
<li><p>类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。<strong>回溯法的求解目标是找出T中满足约束条件的所有解</strong>，而<strong>分支限界法</strong>的求解目标则是找出<strong>满足约束条件的一个解</strong>，或是在满足约束条件的解中找出使某一目标函数值达到<strong>极大或极小的解</strong>，即在某种意义下的<strong>最优解</strong>。</p>
</li>
<li><p>（1）分支搜索算法</p>
</li>
<li><p>所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。</p>
</li>
<li><p>选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。</p>
</li>
<li><p>1）FIFO搜索</p>
</li>
<li><p>2）LIFO搜索</p>
</li>
<li><p>3）优先队列式搜索</p>
</li>
<li><p>（2）分支限界搜索算法 </p>
</li>
</ul>
</li>
<li><p>二、分支限界法的一般过程</p>
<ul>
<li><p>由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。<strong>回溯法以深度优先的方式搜索解空间树T</strong>，而<strong>分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T</strong>。</p>
</li>
<li><p>分支限界法的<strong>搜索策略是</strong>：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p>
</li>
<li><p>分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的<strong>解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树</strong>。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p>
</li>
</ul>
</li>
<li><p>三、回溯法和分支限界法的一些区别</p>
<ul>
<li><p>有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p>
</li>
<li><p>回溯法和分支限界法的一些区别：</p>
</li>
<li><p>方法对解空间树的搜索方式 <a href="http://www.storworld.com/">存储</a>结点的常用数据结构结点<a href="http://www.storworld.com/">存储</a>特性常用应用</p>
</li>
<li><p>回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</p>
</li>
<li><p>分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招面试</title>
    <url>/qyaaaa.github.io/2020/10/24/%E6%B5%99%E6%B1%9F%E5%A4%A7%E5%8D%8E%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><p><strong>1、多线程的死锁以及如何定位死锁问题？</strong></p>
<p><strong>2、多线程如何防止死锁？</strong></p>
<p><strong>3、深度优先搜素和广度优先搜索？</strong></p>
<p><strong>4、jvm的内存模型？</strong></p>
<p><strong>5、jvm调优？</strong></p>
<p><strong>6、垃圾回收？</strong></p>
<p><strong>7、linux的查看进程？</strong></p>
]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>算法小技巧</title>
    <url>/qyaaaa.github.io/2021/04/25/%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="算法小技巧"><a href="#算法小技巧" class="headerlink" title="算法小技巧"></a>算法小技巧</h1><ul>
<li>将一个10进制数转化为k进制的数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = Integer.toString(n,k).toUpperCase();</span><br><span class="line"><span class="keyword">int</span> number = Integer.parseInt(s);</span><br></pre></td></tr></table></figure>

<ul>
<li>将一个char转化为int型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = s.charAt(i) - <span class="number">48</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成树</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    </span><br><span class="line">    TreeNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode(<span class="keyword">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将小写字母转换为大写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char a &#x3D; &#39;a&#39;;</span><br><span class="line">char A &#x3D; (char)(a ^ 32);&#x2F;&#x2F;按位异或</span><br><span class="line">System.out.println(A);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/qyaaaa.github.io/2020/06/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取电脑核数System.out.println(Runtime.getRuntime().availableProcessors());</span></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                Runtime.getRuntime().availableProcessors(),<span class="comment">//cpu密集型</span></span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(), </span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()    <span class="comment">//四种拒绝策略之一</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++)&#123;</span><br><span class="line">                threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;ok&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/qyaaaa.github.io/2020/12/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="一、计算机网络的五层模型"><a href="#一、计算机网络的五层模型" class="headerlink" title="一、计算机网络的五层模型"></a>一、计算机网络的五层模型</h2><p><strong>五层模型：物理层、数据链路层、网络层、运输层、应用层。</strong></p>
<p><strong>应用层</strong>：通过应用进程之间的交互来完成特定的网络应用。（DNS、HTTP、STMP协议等）</p>
<p><strong>运输层</strong>：负责向两台主机进程之间的通信提供通用的数据传输服务。</p>
<ul>
<li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li>
<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>
<li>tcp 面向字节流，udp 面向报文；</li>
<li>tcp 数据传输慢，udp 数据传输快；</li>
</ul>
<p><strong>网络层</strong>：选择适当的网间路由和交换节点，确保数据及时传送。</p>
<p><strong>数据链路层</strong>：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要专门的链路层协议。</p>
<p><strong>物理层</strong>：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</p>
<h2 id="二、三次握手与四次挥手"><a href="#二、三次握手与四次挥手" class="headerlink" title="二、三次握手与四次挥手"></a>二、三次握手与四次挥手</h2><h3 id="2-1三次握手"><a href="#2-1三次握手" class="headerlink" title="2.1三次握手"></a>2.1三次握手</h3><ul>
<li>建立连接时，客户端发送SYN包到服务器，其中包含客户端的初始序号seq=x，并进入SYN_SENT状态，等待服务器确认。（其中，SYN=1，ACK=0，表示这是一个TCP连接请求数据报文；序号seq=x，表明传输数据时的第一个数据字节的序号是x）。</li>
<li>服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。（其中确认报文段中，标识位SYN=1，ACK=1，表示这是一个TCP连接响应数据报文，并含服务端的初始序号seq(服务器)=y，以及服务器对客户端初始序号的确认号ack(服务器)=seq(客户端)+1=x+1）。</li>
<li>客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，客户端和服务器进入ESTAB_LISHED(TCP连接成功)状态，完成三次握手。</li>
</ul>
<h3 id="2-2为什么要三次握手"><a href="#2-2为什么要三次握手" class="headerlink" title="2.2为什么要三次握手"></a>2.2为什么要三次握手</h3><ul>
<li>我们来分析一种特殊情况，假设客户端请求建立连接，发给服务器SYN包等待服务器确认，服务器收到确认后，如果是两次握手，假设服务器给客户端在第二次握手时发送数据，数据从服务器发出，服务器认为连接已经建立，但在发送数据的过程中数据丢失，客户端认为连接没有建立，会进行重传。假设每次发送的数据一直在丢失，客户端一直SYN，服务器就会产生多个无效连接，占用资源，这个时候服务器可能会挂掉。这个现象就是我们听过的“SYN的洪水攻击”。</li>
<li>总结：第三次握手是为了防止：如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，但问题是：服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销。</li>
</ul>
<h3 id="2-3四次挥手"><a href="#2-3四次挥手" class="headerlink" title="2.3四次挥手"></a>2.3四次挥手</h3><ul>
<li>首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。</li>
<li>服务器收到这个FIN，它发送一个ACK，确认ack为收到的序号加一。</li>
<li>关闭服务器到客户端的连接，发送一个FIN给客户端。</li>
<li>客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</li>
</ul>
<h3 id="2-4为什么要四次挥手"><a href="#2-4为什么要四次挥手" class="headerlink" title="2.4为什么要四次挥手"></a>2.4为什么要四次挥手</h3><p><strong>需要四次挥手才能断开连接是因为：TCP是双向对等传输，故有两个方向的连接，需要两个FIN才能断开</strong></p>
<p>总结：</p>
<p>TCP是全双工通信，不能单方面完全断开连接</p>
<ul>
<li>客户端发送<code>FIN</code>：只能断开客户端向服务端方向的连接</li>
<li>服务端发送<code>FIN</code>：只能断开服务端向客户端方向的连接</li>
</ul>
<h2 id="三、流量控制与拥塞控制"><a href="#三、流量控制与拥塞控制" class="headerlink" title="三、流量控制与拥塞控制"></a>三、流量控制与拥塞控制</h2><h3 id="3-1流量控制"><a href="#3-1流量控制" class="headerlink" title="3.1流量控制"></a>3.1流量控制</h3><h4 id="3-1-1流量控制？流量控制的目的？"><a href="#3-1-1流量控制？流量控制的目的？" class="headerlink" title="3.1.1流量控制？流量控制的目的？"></a>3.1.1流量控制？流量控制的目的？</h4><p>如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。</p>
<h4 id="3-1-2如何实现流量控制？"><a href="#3-1-2如何实现流量控制？" class="headerlink" title="3.1.2如何实现流量控制？"></a>3.1.2如何实现流量控制？</h4><p>主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。</p>
<h4 id="3-1-3-流量控制引发的死锁？怎么避免死锁的发生？"><a href="#3-1-3-流量控制引发的死锁？怎么避免死锁的发生？" class="headerlink" title="3.1.3 流量控制引发的死锁？怎么避免死锁的发生？"></a>3.1.3 流量控制引发的死锁？怎么避免死锁的发生？</h4><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</p>
<p>为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p>
<h3 id="3-2-拥塞控制"><a href="#3-2-拥塞控制" class="headerlink" title="3.2 拥塞控制"></a>3.2 拥塞控制</h3><h4 id="3-2-1-慢开始、拥塞避免"><a href="#3-2-1-慢开始、拥塞避免" class="headerlink" title="3.2.1 慢开始、拥塞避免"></a>3.2.1 慢开始、拥塞避免</h4><p><strong>整个拥塞控制的流程如下图：</strong><br><img src="https://img-blog.csdnimg.cn/20190409114430732.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dlbmd6aGlrdWkxOTky,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>（1）拥塞窗口cwnd初始化为1个报文段，慢开始门限初始值为16<br>（2）执行慢开始算法，指数规律增长到第4轮，即cwnd=16=ssthresh，改为执行拥塞避免算法，拥塞窗口按线性规律增长<br>（3）假定cwnd=24时，网络出现超时（拥塞），则更新后的ssthresh=12，cwnd重新设置为1，并执行慢开始算法。当cwnd=12=ssthresh时，改为执行拥塞避免算法</p>
<h4 id="3-2-2-快重传、快恢复"><a href="#3-2-2-快重传、快恢复" class="headerlink" title="3.2.2 快重传、快恢复"></a>3.2.2 快重传、快恢复</h4><p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法</p>
<p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。如下图：TCP Reno版本是目前使用最广泛的版本。</p>
<p><img src="https://img-blog.csdnimg.cn/2019040911481819.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dlbmd6aGlrdWkxOTky,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>注意：在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用</p>
<h4 id="3-2-3-拥塞控制和流量控制的区别"><a href="#3-2-3-拥塞控制和流量控制的区别" class="headerlink" title="3.2.3 拥塞控制和流量控制的区别"></a>3.2.3 拥塞控制和流量控制的区别</h4><ul>
<li>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</li>
<li>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。</li>
</ul>
<h2 id="五、在浏览器中输入url地址-gt-gt-显示主页的过程"><a href="#五、在浏览器中输入url地址-gt-gt-显示主页的过程" class="headerlink" title="五、在浏览器中输入url地址 -&gt;&gt; 显示主页的过程"></a>五、在浏览器中输入url地址 -&gt;&gt; 显示主页的过程</h2><p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h2 id="六、http的执行流程？"><a href="#六、http的执行流程？" class="headerlink" title="六、http的执行流程？"></a><strong>六、http的执行流程？</strong></h2><ul>
<li>1.用户在浏览器中输入网址</li>
<li>2.浏览器拿到网址后通过dns，查询他的ip地址</li>
<li>3.dns服务器根据网址返回ip地址</li>
<li>4.浏览器得到地址后，和该地址建立一条通道（tcp连接）</li>
<li>5.浏览器向服务器发送一个请求，包含url，协议版本号（http1.0等），协议头（请求的方法get， 客户端cookie，agent信息头等等），协议内容等等</li>
<li>6.服务器拿到请求后，根据请求中的内容找相应的数据，如果不能正常拿到，返回一个错误码（例如404），如果能正常拿到，返回一堆内容（包括正常的状态吗，header头，例如是否压缩，是否分段传输等等。返回实体内容，例如页面的内容）</li>
<li>7.断开连接吗？一般情况下，服务器就关闭了tcp连接，但是如果有connection：keep-alive，则不关闭ctp，下次有请求的时候还会用同一个连接（http1.1）</li>
<li>8.浏览器拿到返回的数据，开始渲染html数据并展示给用户</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络相关</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/qyaaaa.github.io/2020/04/23/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序的基本思想：从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] num &#x3D; &#123;60,80,19,23,56,108&#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 1. 外层for循环控制选择的轮数</span><br><span class="line">        for(int i&#x3D;0;i&lt;num.length-1;i++)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 2. 内层for循环：控制每轮比较的次数</span><br><span class="line">            for(int j&#x3D;i+1;j&lt;num.length;j++)&#123;</span><br><span class="line">                if(num[i]&gt;num[j])&#123;</span><br><span class="line">                    int temp &#x3D; num[i];</span><br><span class="line">                    num[i]&#x3D;num[j];</span><br><span class="line">                    num[j]&#x3D;temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 遍历数组，输出</span><br><span class="line">        for(int i&#x3D;0;i&lt;num.length;i++)&#123;</span><br><span class="line">            System.out.print(num[i]+&quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">19	23	56	60	80	108	</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/qyaaaa.github.io/2020/08/30/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h4 id="1-ArrayList-和-Vector"><a href="#1-ArrayList-和-Vector" class="headerlink" title="1. ArrayList 和 Vector"></a>1. ArrayList 和 Vector</h4><ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量且 ArrayList 与Vector 都有一个初始的容量大小，当存储进他们里面的元素个数超过了容量时，就需要增加ArrayList与Vector的存储空间， 每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取的一定的平衡。Vector默认增加为原来的两倍，而ArrayList默认为 1.5倍，ArrayList和Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而Arraylist 没有设置增长空间的方法。 及Vector增长原来的1倍，Arraylist增长原来的0.5倍。（ArrayList在new的时候为0，add的时候才是10。vector默认为10）</li>
</ul>
<h4 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2.HashMap"></a><strong>2.HashMap</strong></h4><ul>
<li>HashMap的无参构造方法中初始容量为0（初次调用put()会更新为16，门限会更新为12=16*0.75）</li>
<li>HashMap扩容时，如果旧容量大于等于最大容量(2^30),则不扩容，设置新的门限=2^31 -1；反之新容量=旧容量的2倍，新门限=旧门限的2倍</li>
</ul>
<h4 id="3-Array-和-ArrayList-有何区别？"><a href="#3-Array-和-ArrayList-有何区别？" class="headerlink" title="3. Array 和 ArrayList 有何区别？"></a>3. Array 和 ArrayList 有何区别？</h4><ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<h4 id="4-怎么确保一个集合不能被修改？"><a href="#4-怎么确保一个集合不能被修改？" class="headerlink" title="4. 怎么确保一个集合不能被修改？"></a>4. 怎么确保一个集合不能被修改？</h4><ul>
<li>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</li>
</ul>
<h4 id="5-ArrayList-和-LinkedList-的区别是什么？"><a href="#5-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="5. ArrayList 和 LinkedList 的区别是什么？"></a>5. ArrayList 和 LinkedList 的区别是什么？</h4><ul>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
<li>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li>
</ul>
<h4 id="6-如何实现数组和-List-之间的转换？"><a href="#6-如何实现数组和-List-之间的转换？" class="headerlink" title="6. 如何实现数组和 List 之间的转换？"></a>6. 如何实现数组和 List 之间的转换？</h4><ul>
<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。</li>
</ul>
<h4 id="7-在-Queue-中-poll-和-remove-有什么区别？"><a href="#7-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="7. 在 Queue 中 poll()和 remove()有什么区别？"></a>7. 在 Queue 中 poll()和 remove()有什么区别？</h4><ul>
<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>
<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li>
</ul>
]]></content>
      <categories>
        <category>集合相关</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招面试</title>
    <url>/qyaaaa.github.io/2020/08/26/%E9%9D%A2%E8%AF%951/</url>
    <content><![CDATA[<h2 id="2020秋招部分面试："><a href="#2020秋招部分面试：" class="headerlink" title="2020秋招部分面试："></a>2020秋招部分面试：</h2><h4 id="面一"><a href="#面一" class="headerlink" title="面一:"></a><strong>面一:</strong></h4><p><strong>1</strong>、ArrayList和LinkedList区别？<br><strong>2</strong>、链表和数组的区别？<br><strong>3</strong>、synchronized和volite区别？<br><strong>4</strong>、MySQL有几种索引？详细说一下？<br><strong>5</strong>、HashMap底层实现原理？<br><strong>6</strong>、说一下哈希表？<br><strong>7</strong>、两个有序数组的合并？复杂度？<br><strong>8</strong>、Java序列化及作用？<br><strong>9</strong>、sychronized可以修饰什们？修饰一个类作用的是什么？<br><strong>10</strong>、ArrayList初始容量及扩容？<br><strong>11</strong>、字节流和字符流的区别？</p>
<h4 id="面二"><a href="#面二" class="headerlink" title="面二:"></a><strong>面二</strong>:</h4><p><strong>1</strong>、为什么要创建索引？<br><strong>2</strong>、为什么要使用锁？<br><strong>3</strong>、介绍一下公平锁和非公平锁的使用？<br><strong>4</strong>、举例子说一下事务的一致性？<br><strong>5</strong>、说一下redis有哪些类型？运用在哪里<br><strong>6</strong>、说一下token？<br><strong>7</strong>、说一下拦截器、过滤器、ioc的执行顺序？？</p>
<h4 id="面三："><a href="#面三：" class="headerlink" title="面三："></a><strong>面三：</strong></h4><p><strong>1</strong>、JVM内存模型？<br><strong>2</strong>、gc垃圾回收机制？<br><strong>3</strong>、堆和栈的区别？</p>
<h4 id="面四："><a href="#面四：" class="headerlink" title="面四："></a><strong>面四：</strong></h4><p><strong>1</strong>、说一下Java内存模型？(JMM)<br><strong>2</strong>、说一下数据库的分页语句及其参数？<br><strong>3</strong>、说一下Tcp的流量控制及拥塞避免<br><strong>4</strong>、redis中点赞关注的实现？<br><strong>5</strong>、线程池的创建方式？<br><strong>6</strong>、线程池有哪些状态？<br><strong>7</strong>、ArrayList和HashMap的扩容及其参数？</p>
]]></content>
      <categories>
        <category>面试相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/qyaaaa.github.io/2020/12/16/Docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><blockquote>
<p>学习自狂神说:<a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=15">https://www.bilibili.com/video/BV1og4y1q7M4?p=15</a></p>
</blockquote>
<ul>
<li>Docker 学习</li>
<li>Docker 概述</li>
<li>Docker安装</li>
<li>Docker命令<ul>
<li>镜像命令</li>
<li>容器命令</li>
<li>操作命令</li>
<li>…</li>
</ul>
</li>
<li>Docker镜像</li>
<li>容器数据卷</li>
<li>DockerFile</li>
<li>Docker网络原理</li>
<li>IDEA整合Docker（单机Docker)</li>
<li>Docker Compose</li>
<li>Docker Swarm</li>
<li>CI\CD Jenkins</li>
</ul>
<h2 id="一、Docker概述"><a href="#一、Docker概述" class="headerlink" title="一、Docker概述"></a>一、Docker概述</h2><h3 id="Docker为什么出现？"><a href="#Docker为什么出现？" class="headerlink" title="Docker为什么出现？"></a>Docker为什么出现？</h3><p>一款产品： 开发–上线 两套环境！应用环境，应用配置！</p>
<p>开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？</p>
<p>环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。</p>
<p>发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！</p>
<p>之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。</p>
<p>开发环境Windows，最后发布到Linux！</p>
<p>传统：开发jar，运维来做！</p>
<p>现在：开发打包部署上线，一套流程做完！</p>
<p>安卓流程：java — apk —发布（应用商店）一 张三使用apk一安装即可用！</p>
<p>docker流程： java-jar（环境） — 打包项目帯上环境（镜像） — ( Docker仓库：商店）—–</p>
<p>Docker给以上的问题，提出了解决方案！</p>
<p><strong>Docker的思想就来自于集装箱！</strong></p>
<p>JRE – 多个应用(端口冲突) – 原来都是交叉的！<br>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p>
<p>Docker通过隔离机制，可以将服务器利用到极致！</p>
<h3 id="Docker历史"><a href="#Docker历史" class="headerlink" title="Docker历史"></a>Docker历史</h3><p>2010年，几个的年轻人，就在美国成立了一家公司 <code>dotcloud</code></p>
<p>做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！</p>
<blockquote>
<p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p>
</blockquote>
<p>他们将自己的技术（容器化技术）命名就是 Docker<br>Docker刚刚延生的时候，没有引起行业的注意！<code>dotCloud</code>，就活不下去！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开源</span><br></pre></td></tr></table></figure>

<p>2013年，Docker开源！</p>
<p>越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！</p>
<p>2014年4月9日，Docker1.0发布！</p>
<p>docker为什么这么火？十分的轻巧！</p>
<p>在容器技术出来之前，我们都是使用虚拟机技术！</p>
<p>虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！</p>
<p>虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vm : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟</span><br><span class="line">docker: 隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<blockquote>
<p>聊聊Docker</p>
</blockquote>
<p>Docker基于Go语言开发的！开源项目！</p>
<p>docker官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a> Docker的文档是超级详细的！</p>
<p>仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h3 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h3><blockquote>
<p>之前的虚拟机技术！</p>
</blockquote>
<p>![CRO9M6_C_8`FBF_TXLEQ_AT.png](<a href="https://i.loli.net/2020/12/17/sk15ZWKgExJHnIu.png">https://i.loli.net/2020/12/17/sk15ZWKgExJHnIu.png</a>)</p>
<p><strong>虚拟机技术缺点</strong>：</p>
<p>1、 资源占用十分多</p>
<p>2、 冗余步骤多</p>
<p>3、 启动很慢！</p>
<blockquote>
<p>容器化技术</p>
</blockquote>
<p>容器化技术不是模拟一个完整的操作系统</p>
<p>![NT~7M5M4_`LM_FXKT3_SHW3.png](<a href="https://i.loli.net/2020/12/17/HTCtavsEPJSz5MX.png">https://i.loli.net/2020/12/17/HTCtavsEPJSz5MX.png</a>)</p>
<p>比较Docker和虚拟机技术的不同：</p>
<ul>
<li>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</li>
<li>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响</li>
</ul>
<blockquote>
<p>DevOps（开发、运维）</p>
</blockquote>
<p><strong>应用更快速的交付和部署</strong></p>
<p>传统：一对帮助文档，安装程序。</p>
<p>Docker：打包镜像发布测试一键运行。</p>
<p><strong>更便捷的升级和扩缩容</strong></p>
<p>使用了 Docker之后，我们部署应用就和搭积木一样<br>项目打包为一个镜像，扩展服务器A！服务器B</p>
<p><strong>更简单的系统运维</strong><br>在容器化之后，我们的开发，测试环境都是高度一致的</p>
<p><strong>更高效的计算资源利用</strong></p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</p>
<h2 id="二、Docker安装"><a href="#二、Docker安装" class="headerlink" title="二、Docker安装"></a>二、Docker安装</h2><h3 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h3><p>![_U~VY2MPQ___6Q_EBJ`46M3.png](<a href="https://i.loli.net/2020/12/17/Hvthijzkf84Pe2s.png">https://i.loli.net/2020/12/17/Hvthijzkf84Pe2s.png</a>)</p>
<p><strong>镜像（image)：</strong></p>
<p>docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像==&gt;run==&gt;容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p>
<p><strong>容器(container)：</strong></p>
<p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.<br>启动，停止，删除，基本命令<br>目前就可以把这个容器理解为就是一个简易的 Linux系统。</p>
<p><strong>仓库(repository)：</strong></p>
<p>仓库就是存放镜像的地方！<br>仓库分为公有仓库和私有仓库。(很类似git)<br>Docker Hub是国外的。<br>阿里云…都有容器服务器(配置镜像加速!)</p>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><blockquote>
<p>环境查看</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@qy ~]# uname -r</span><br><span class="line">3.10.0-514.26.2.el7.x86_64 # 要求3.0以上</span><br><span class="line">[root@qy ~]# cat &#x2F;etc&#x2F;os-release </span><br><span class="line">NAME&#x3D;&quot;CentOS Linux&quot;</span><br><span class="line">VERSION&#x3D;&quot;7 (Core)&quot;</span><br><span class="line">ID&#x3D;&quot;centos&quot;</span><br><span class="line">ID_LIKE&#x3D;&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID&#x3D;&quot;7&quot;</span><br><span class="line">PRETTY_NAME&#x3D;&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="line">ANSI_COLOR&#x3D;&quot;0;31&quot;</span><br><span class="line">CPE_NAME&#x3D;&quot;cpe:&#x2F;o:centos:centos:7&quot;</span><br><span class="line">HOME_URL&#x3D;&quot;https:&#x2F;&#x2F;www.centos.org&#x2F;&quot;</span><br><span class="line">BUG_REPORT_URL&#x3D;&quot;https:&#x2F;&#x2F;bugs.centos.org&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT&#x3D;&quot;CentOS-7&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION&#x3D;&quot;7&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT&#x3D;&quot;centos&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION&#x3D;&quot;7&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、卸载旧版本</span><br><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">2、需要的安装包</span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">3、设置镜像的仓库</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line">#推荐使用国内的</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line">    </span><br><span class="line">#更新yum软件包索引</span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">4、安装docker相关的 docker-ce 社区版 而ee是企业版</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line">5、启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">6、 使用docker version查看是否按照成功</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line">7、 测试</span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line">8、查看镜像</span><br><span class="line">[root@qy &#x2F;]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        11 months ago       13.3kB</span><br><span class="line"></span><br><span class="line">卸载docker</span><br><span class="line">卸载依赖</span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line">删除资源</span><br><span class="line">rm -rf &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure>

<h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><p>1、登录阿里云找到容器服务</p>
<p>2、找到镜像加速器</p>
<p><img src="https://i.loli.net/2020/12/20/quTD3UfEsXh5vLm.png" alt="UQAK___~@4TME_Z5VTHC@2H.png"></p>
<p>3、配置使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line"></span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;ncvcpaxn.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>docker run的流程图</p>
<p><img src="https://i.loli.net/2020/12/20/a7fY4sQA5y6gC1v.png" alt="__L_RH_`JY`5Y89AFXK2V98.png"></p>
<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>Docker<strong>是怎么工作的</strong>？</p>
<p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</p>
<p>Docker-Server接收到Docker-Client的指令，就会执行这个命令！</p>
<p><img src="https://i.loli.net/2020/12/20/omIVf7jsvQgpCUK.png" alt="7GL__E5B_PS9JJS9RC_RWM4.png"></p>
<p><strong>为什么Docker比Vm快</strong><br>1、docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现<strong>硬件资源虚拟化</strong>,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>2、docker利用的是宿主机的内核,而不需要Guest OS。</p>
<p><img src="https://i.loli.net/2020/12/20/KixaQeTjF8E4kOI.png" alt="M4WB__2HI_RHA6A_IFVT__5.png"></p>
<p>因此,当新建一个 容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引导、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是<strong>分钟级别</strong>的。而docker由于直接利用宿主机的操作系统,则省略了这个复杂的过程,因此新建一个docker容器只需要<strong>几秒钟</strong>。</p>
<h2 id="三、Docker的常用命令"><a href="#三、Docker的常用命令" class="headerlink" title="三、Docker的常用命令"></a>三、Docker的常用命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version    #显示docker的版本信息。</span><br><span class="line">docker info       #显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker --help #帮助命令</span><br></pre></td></tr></table></figure>

<p>帮助文档的地址：<a href="https://docs.docker.com/engine/reference/commandline/build/">https://docs.docker.com/engine/reference/commandline/build/</a></p>
<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><blockquote>
<p>docker images #查看所有本地主机上的镜像 可以使用docker image ls代替</p>
<p>docker search 搜索镜像</p>
<p>docker pull 下载镜像 docker image pull</p>
<p>docker rmi 删除镜像 docker image rm</p>
</blockquote>
<p><strong>docker images</strong> 查看所有本地的主机上的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@qy ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        11 months ago       13.3kB</span><br><span class="line"></span><br><span class="line"># 解释</span><br><span class="line">#REPOSITORY			# 镜像的仓库源</span><br><span class="line">#TAG				# 镜像的标签</span><br><span class="line">#IMAGE ID			# 镜像的id</span><br><span class="line">#CREATED			# 镜像的创建时间</span><br><span class="line">#SIZE				# 镜像的大小</span><br><span class="line"></span><br><span class="line"># 可选项</span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all images (default hides intermediate images) #列出所有镜像</span><br><span class="line">  -q, --quiet           Only show numeric IDs # 只显示镜像的id</span><br><span class="line">  </span><br><span class="line">docker images -aq ＃显示所有镜像的id</span><br><span class="line">[root@qy ~]# docker images -aq</span><br><span class="line">bf756fb1ae65</span><br></pre></td></tr></table></figure>

<p><strong>docker search 搜索镜像</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@qy ~]# docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10295               [OK]                </span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   3809                [OK] </span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --limit int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don&#39;t truncate output</span><br><span class="line">      </span><br><span class="line">#过滤 </span><br><span class="line"># --filter&#x3D;STARS&#x3D;3000 #搜索出来的镜像就是STARS大于3000的</span><br><span class="line">docker search mysql --filter&#x3D;STARS&#x3D;3000</span><br></pre></td></tr></table></figure>

<p><strong>docker pull</strong> 下载镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载镜像 docker pull 镜像名[:tag]</span><br><span class="line">[root@qy ~]# docker pull mysql</span><br><span class="line">Using default tag: latest #如果不写tag，默认就是latest</span><br><span class="line">latest: Pulling from library&#x2F;mysql</span><br><span class="line">6ec7b7d162b2: Pull complete #分层下载： docker image 的核心 联合文件系统</span><br><span class="line">fedd960d3481: Pull complete </span><br><span class="line">7ab947313861: Pull complete </span><br><span class="line">64f92f19e638: Pull complete </span><br><span class="line">3e80b17bff96: Pull complete </span><br><span class="line">014e976799f9: Pull complete </span><br><span class="line">59ae84fee1b3: Pull complete </span><br><span class="line">ffe10de703ea: Pull complete </span><br><span class="line">657af6d90c83: Pull complete </span><br><span class="line">98bfb480322c: Pull complete </span><br><span class="line">9f2c4202ac29: Pull complete </span><br><span class="line">a369b92bfc99: Pull complete </span><br><span class="line">Digest: sha256:365e891b22abd3336d65baefc475b4a9a1e29a01a7b6b5be04367fcc9f373bb7</span><br><span class="line">Status: Downloaded newer image for mysql:latest #真实地址</span><br><span class="line"></span><br><span class="line">#等价于</span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io&#x2F;library&#x2F;mysql:latest</span><br><span class="line"></span><br><span class="line">#指定版本下载</span><br></pre></td></tr></table></figure>

<p><strong>docker rmi 删除镜像</strong></p>
<blockquote>
<p> docker rmi -f 镜像id <em>#删除指定的镜像</em> </p>
<p> docker rmi -f 镜像id 镜像id 镜像id 镜像id*#删除指定的镜像* </p>
<p>docker rmi -f $(docker images -aq) <em>#删除全部的镜像</em></p>
</blockquote>
<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><blockquote>
<p>docker run 镜像id 新建容器并启动</p>
<p>docker ps 列出所有运行的容器 docker container list</p>
<p>docker rm 容器id 删除指定容器</p>
<p>docker start 容器id #启动容器<br>docker restart 容器id #重启容器<br>docker stop 容器id #停止当前正在运行的容器<br>docker kill 容器id #强制停止当前容器</p>
</blockquote>
<p>说明：我们有了镜像才可以创建容器，Linux，下载centos镜像来学习</p>
<p><strong>新建容器并启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image | docker container run [可选参数] image </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">参数说明</span></span><br><span class="line">--name=&quot;Name&quot;		容器名字 tomcat01 tomcat02 用来区分容器</span><br><span class="line">-d					后台方式运行</span><br><span class="line">-it 				使用交互方式运行，进入容器查看内容</span><br><span class="line">-p					指定容器的端口 -p 8080(宿主机):8080(容器)</span><br><span class="line">		-p ip:主机端口:容器端口</span><br><span class="line">		-p 主机端口:容器端口(常用)</span><br><span class="line">		-p 容器端口</span><br><span class="line">		容器端口</span><br><span class="line">-P(大写) 				随机指定端口</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">测试、启动并进入容器</span></span><br><span class="line">[root@qy ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@0ee238b0f0af /]# </span><br><span class="line">[root@0ee238b0f0af /]# ls #查看</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"></span><br><span class="line">[root@0ee238b0f0af /]# exit #从容器退回主机</span><br><span class="line">exit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>列出所有运行的容器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#docker ps命令 #列出当前正在运行的容器</span><br><span class="line">  -a, --all             Show all containers (default shows just running)</span><br><span class="line">  -n, --last int        Show n last created containers (includes all states) (default -1)</span><br><span class="line">  -q, --quiet           Only display numeric IDs</span><br><span class="line"></span><br><span class="line">[root@qy ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line"></span><br><span class="line">[root@qy ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">0ee238b0f0af        centos              &quot;&#x2F;bin&#x2F;bash&quot;         5 minutes ago       Exited (0) 2 minutes ago                       elastic_shockley</span><br><span class="line">da928b76affb        hello-world         &quot;&#x2F;hello&quot;            20 hours ago        Exited (0) 20 hours ago                        hungry_borg</span><br><span class="line">1aa7c4701ac2        hello-world         &quot;&#x2F;hello&quot;            3 weeks ago         Exited (0) 3 weeks ago                         cranky_davinci</span><br><span class="line">a6ce48d70efb        hello-world         &quot;&#x2F;hello&quot;            2 months ago        Exited (0) 2 months ago                        naughty_driscoll</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit #容器直接退出</span><br><span class="line">ctrl +P +Q #容器不停止退出</span><br></pre></td></tr></table></figure>

<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器id   #删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)  #删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm  #删除所有的容器</span><br></pre></td></tr></table></figure>

<p><strong>启动和停止容器的操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器id	#启动容器</span><br><span class="line">docker restart 容器id	#重启容器</span><br><span class="line">docker stop 容器id	#停止当前正在运行的容器</span><br><span class="line">docker kill 容器id	#强制停止当前容器</span><br></pre></td></tr></table></figure>

<h3 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h3><p><strong>后台启动命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 命令 docker run -d 镜像名</span><br><span class="line">[root@qy ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line"># 问题docker ps. 发现centos 停止了</span><br><span class="line"># 常见的坑，docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止</span><br><span class="line"># nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span><br></pre></td></tr></table></figure>

<p><strong>查看日志</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@qy ~]# docker logs --help</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow log output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42</span><br><span class="line">                       minutes)</span><br><span class="line">      --tail string    Number of lines to show from the end of the logs (default &quot;all&quot;)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for</span><br><span class="line">                       42 minutes)</span><br><span class="line">                       </span><br><span class="line">#显示日志</span><br><span class="line">-tf		#显示日志信息（一直更新）</span><br><span class="line">--tail number #需要显示日志条数</span><br><span class="line">docker logs -t --tail n 容器id #查看n行日志</span><br><span class="line">docker logs -ft 容器id #跟着日志</span><br></pre></td></tr></table></figure>

<p><strong>查看容器中进程信息</strong> ps</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令 docker top 容器id</span></span><br><span class="line"></span><br><span class="line">[root@qy ~]# docker top fc6da4257ab4 </span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                5057                5040                0                   13:23               pts/0               00:00:00            /bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>查看镜像的元数据</strong></p>
<p><em># 命令</em> docker inspect 容器id</p>
<p><strong>进入当前正在运行的容器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span><br><span class="line">#方式一</span><br><span class="line"># 命令 </span><br><span class="line">docker exec -it 容器id bashshell</span><br><span class="line">[root@qy ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">fc6da4257ab4        centos              &quot;&#x2F;bin&#x2F;bash&quot;         25 hours ago        Up 25 hours                             cool_cerf</span><br><span class="line">[root@qy ~]# docker exec -it fc6da4257ab4 &#x2F;bin&#x2F;bash</span><br><span class="line">[root@fc6da4257ab4 &#x2F;]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"></span><br><span class="line">#方式二</span><br><span class="line">docker attach 容器id</span><br><span class="line">[root@qy ~]# docker attach fc6da4257ab4</span><br><span class="line">[root@fc6da4257ab4 &#x2F;]# </span><br><span class="line">区别</span><br><span class="line">#docker exec #进入当前容器后开启一个新的终端，可以在里面操作。（常用）</span><br><span class="line">#docker attach # 进入容器正在执行的终端</span><br></pre></td></tr></table></figure>

<p><strong>从容器内拷贝到主机上</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 容器id:容器内路径   主机目的路径</span><br><span class="line"></span><br><span class="line">[root@qy home]# ls</span><br><span class="line">dstsave    git      linux64  public  qy     siteserverui  steamcmd               steamcmd.sh</span><br><span class="line">dstserver  linux32  package  qiao    redis  steam         steamcmd_linux.tar.gz  www</span><br><span class="line">[root@qy home]# cd &#x2F;</span><br><span class="line">[root@qy &#x2F;]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">fc6da4257ab4        centos              &quot;&#x2F;bin&#x2F;bash&quot;         25 hours ago        Up 25 hours                             cool_cerf</span><br><span class="line">#进入docker容器内部</span><br><span class="line">[root@qy &#x2F;]# docker attach fc6da4257ab4</span><br><span class="line">[root@fc6da4257ab4 &#x2F;]# cd &#x2F;home</span><br><span class="line">[root@fc6da4257ab4 home]# ls</span><br><span class="line">#新建一个文件</span><br><span class="line">[root@fc6da4257ab4 home]# touch test.java</span><br><span class="line">[root@fc6da4257ab4 home]# exit</span><br><span class="line">exit</span><br><span class="line">[root@qy &#x2F;]# cd &#x2F;home</span><br><span class="line">#拷贝</span><br><span class="line">[root@qy home]# docker cp fc6da4257ab4:&#x2F;home&#x2F;test.java &#x2F;home</span><br><span class="line">[root@qy home]# ls</span><br><span class="line">dstsave    git      linux64  public  qy     siteserverui  steamcmd               steamcmd.sh  www</span><br><span class="line">dstserver  linux32  package  qiao    redis  steam         steamcmd_linux.tar.gz  test.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![~8L9M__@1_XH@U1@MW_E`_0.png](<a href="https://i.loli.net/2020/12/22/qQ3nZaArUiNukjB.png">https://i.loli.net/2020/12/22/qQ3nZaArUiNukjB.png</a>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">#当前shell下 attach连接指定运行的镜像</span><br><span class="line">build       Build an image from a Dockerfile # 通过Dockerfile定制镜像</span><br><span class="line">commit      Create a new image from a container&#39;s changes #提交当前容器为新的镜像</span><br><span class="line">cp          Copy files&#x2F;folders between a container and the local filesystem #拷贝文件</span><br><span class="line">create      Create a new container #创建一个新的容器</span><br><span class="line">diff        Inspect changes to files or directories on a container&#39;s filesystem #查看docker容器的变化</span><br><span class="line">events      Get real time events from the server # 从服务获取容器实时时间</span><br><span class="line">exec        Run a command in a running container # 在运行中的容器上运行命令</span><br><span class="line">export      Export a container&#39;s filesystem as a tar archive #导出容器文件系统作为一个tar归档文件[对应import]</span><br><span class="line">history     Show the history of an image # 展示一个镜像形成历史</span><br><span class="line">images      List images #列出系统当前的镜像</span><br><span class="line">import      Import the contents from a tarball to create a filesystem image #从tar包中导入内容创建一个文件系统镜像</span><br><span class="line">info        Display system-wide information # 显示全系统信息</span><br><span class="line">inspect     Return low-level information on Docker objects #查看容器详细信息</span><br><span class="line">kill        Kill one or more running containers # kill指定docker容器</span><br><span class="line">load        Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载一个镜像[对应save]</span><br><span class="line">login       Log in to a Docker registry #</span><br><span class="line">logout      Log out from a Docker registry</span><br><span class="line">logs        Fetch the logs of a container</span><br><span class="line">pause       Pause all processes within one or more containers</span><br><span class="line">port        List port mappings or a specific mapping for the container</span><br><span class="line">ps          List containers</span><br><span class="line">pull        Pull an image or a repository from a registry</span><br><span class="line">push        Push an image or a repository to a registry</span><br><span class="line">rename      Rename a container</span><br><span class="line">restart     Restart one or more containers</span><br><span class="line">rm          Remove one or more containers</span><br><span class="line">rmi         Remove one or more images</span><br><span class="line">run         Run a command in a new container</span><br><span class="line">save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">search      Search the Docker Hub for images</span><br><span class="line">start       Start one or more stopped containers</span><br><span class="line">stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">stop        Stop one or more running containers</span><br><span class="line">tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">top         Display the running processes of a container</span><br><span class="line">unpause     Unpause all processes within one or more containers</span><br><span class="line">update      Update configuration of one or more containers</span><br><span class="line">version     Show the Docker version information</span><br><span class="line">wait        Block until one or more containers stop, then print their exit codes</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Docker 安装Nginx</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 搜索</span><br><span class="line">[root@qy home]# docker search nginx</span><br><span class="line"># 下载</span><br><span class="line">docker pull nginx</span><br><span class="line"># -d 后台运行</span><br><span class="line"># --name 给容器命名</span><br><span class="line"># -p 宿主机端口：容器内部端口</span><br><span class="line">docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line"></span><br><span class="line">[root@qy home]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                  NAMES</span><br><span class="line">2d9289fffd09        nginx               &quot;&#x2F;docker-entrypoint.…&quot;   About a minute ago   Up 20 seconds       0.0.0.0:3344-&gt;80&#x2F;tcp   nginx01</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/12/22/nbzsrZeS8vy3MQX.png" alt="_6AM@V__F285TULJ_Z3_E0G.png"></p>
]]></content>
      <categories>
        <category>容器相关</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/qyaaaa.github.io/2020/12/01/elasticsearch/</url>
    <content><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><blockquote>
<p>学习自狂神说:<a href="https://www.bilibili.com/video/BV1Nk4y1R7Hf">https://www.bilibili.com/video/BV1Nk4y1R7Hf</a></p>
</blockquote>
<h2 id="一、Elasticsearch和solr比较"><a href="#一、Elasticsearch和solr比较" class="headerlink" title="一、Elasticsearch和solr比较"></a>一、Elasticsearch和solr比较</h2><ol>
<li>当单纯的对已有的数据进行搜索时，solr更快</li>
<li>当实时建立索引时，Solr会产生io阻塞，查询性能交叉，ElasticSearch具有明显优势</li>
<li>随着数量的增加，Solr的搜索效率会变得更低，而ElasticSearch却没有明显的变化</li>
</ol>
<h2 id="二、ElasticSearch和Solr的比较总结"><a href="#二、ElasticSearch和Solr的比较总结" class="headerlink" title="二、ElasticSearch和Solr的比较总结"></a>二、<strong>ElasticSearch和Solr的比较总结</strong></h2><ol>
<li>es基本是开箱即用(解压就可以使用) 非常简单 Solr安装略微复杂一丢丢</li>
<li>Solr利用Zookeeper进行分布式管理，而ElasticSearch 自身带有分布式协调管理功能</li>
<li>Solr支持更多格式的数据，比如JSON、XML、CSV，而ElasticSearch仅支持json文件格式</li>
<li>Solr光放提供的功能更多，而ElasticSearch本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要kibana友好支撑</li>
<li>Solr查询快，但更新索引慢（插入删除慢），用于电商等查询多的应用<ul>
<li>ES建立索引快（查询慢），即实时性查询快，用于facebook、新浪等搜索</li>
<li>Solr是传统搜索应用的有力解决方案，但ElasticSearch更适用于新兴的实时搜索应用</li>
</ul>
</li>
<li>Solr比较成熟，有一个更大，更成熟的用户，开发和贡献者社区，而ElasticSearch相对开发维护者较少，更新太快，学习使用成本较高（趋势）。</li>
</ol>
<blockquote>
<p>了解ELK</p>
</blockquote>
<p>ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。市面上也被成为Elastic Stack。其中Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为es.Logstash是ELK的中央数据流引擎，用于从不同目标（文俐数据存储/MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地(文件/MQ/redis/elasticsearch/kafka等)。Kibana可以将elasticsearch的数据通过友好的页面展示出来，提供实时分析的功能。<br>市面上很多开发只要提到ELK能够一致说出它是一个日志分析架构技术栈总称，但实际上ELK不仅仅适用于日志分析，它还可以支持其它任何数据分析和收集的场景，日志分析和收集只是更具有代表性。并非唯一性。</p>
<h2 id="三、下载与安装ElasticSearch"><a href="#三、下载与安装ElasticSearch" class="headerlink" title="三、下载与安装ElasticSearch"></a>三、下载与安装ElasticSearch</h2><p>声明：最低要求JDK1.8，下载ElasticSearch客户端、界面工具</p>
<p>Version: 7.10.1(7.6.2)</p>
<p>Release date: December 10, 2020</p>
<p>下载链接：</p>
<ul>
<li><p><a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p>
</li>
<li><p><a href="https://mirrors.huaweicloud.com/elasticsearch/?C=N&amp;O=D%EF%BC%88%E5%8D%8E%E4%B8%BA%E4%BA%91%E9%95%9C%E5%83%8F%EF%BC%89">https://mirrors.huaweicloud.com/elasticsearch/?C=N&amp;O=D（华为云镜像）</a></p>
</li>
</ul>
<p>ELK三剑客，解压即用（需要一些nodejs环境等）</p>
<p>熟悉目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin： 启动文件</span><br><span class="line">config：配置文件</span><br><span class="line">	log4j：日志配置文件</span><br><span class="line">	jvm.options：java虚拟机配置</span><br><span class="line">	elasticsearch.yml：elasticsearch配置文件。默认9200端口！跨域！ </span><br><span class="line">lib：相关jar包</span><br><span class="line">logs：日志</span><br><span class="line">modules：功能模块</span><br><span class="line">plugins：插件</span><br></pre></td></tr></table></figure>

<p>启动：</p>
<p>bin目录下的elasticsearch.bat文件</p>
<p>查看：</p>
<p><a href="http://localhost:9200/%E8%BF%9B%E8%A1%8C%E6%9F%A5%E7%9C%8B">http://localhost:9200/进行查看</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;LAPTOP-LCPUUO4O&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;sdY-Gj5nSFCoDxLIU4AqpA&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.6.1&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;zip&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;xxxxxxxxxxxxxxxxx&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2020-02-29T00:15:25.529771Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.4.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、下载可视化界面"><a href="#四、下载可视化界面" class="headerlink" title="四、下载可视化界面"></a>四、下载可视化界面</h2><p>地址：<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a></p>
<p>重点：需要nodejs环境</p>
<p>命令：</p>
<ul>
<li><p>npm install</p>
</li>
<li><p>npm run start</p>
</li>
</ul>
<p>之后可登录<a href="http://localhost:9100/%E6%9F%A5%E7%9C%8B">http://localhost:9100/查看</a></p>
<p>配置跨域：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在config文件中的elasticsearch.yml最后添加：</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>

<p>重启es.bat，用<a href="http://localhost:9100/%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5">http://localhost:9100/进行连接</a></p>
<h2 id="五、安装Kibana（版本要一致）"><a href="#五、安装Kibana（版本要一致）" class="headerlink" title="五、安装Kibana（版本要一致）"></a>五、安装Kibana（版本要一致）</h2><blockquote>
<p>Kibana</p>
</blockquote>
<p>Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存诸在Elasticsearch索引中的数据。使用Kibana ,可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板( dashboard ）实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。<br>官网: <a href="https://www.elastic.co/cn/kibana">https://www.elastic.co/cn/kibana</a></p>
<p>下载：<a href="https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D%EF%BC%88%E5%8D%8E%E4%B8%BA%E4%BA%91%E9%95%9C%E5%83%8F%EF%BC%89">https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D（华为云镜像）</a></p>
<p>好处：Elk都是开箱即用</p>
<p>启动：kibana.bat</p>
<p>查看：<a href="http://localhost:5601/">http://localhost:5601/</a></p>
<p>汉化：</p>
<ul>
<li>在config中的yml文件中添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i18n.locale: &quot;zh-CN&quot;</span><br></pre></td></tr></table></figure>

<h2 id="六、ElasticSearch的核心概念"><a href="#六、ElasticSearch的核心概念" class="headerlink" title="六、ElasticSearch的核心概念"></a>六、ElasticSearch的核心概念</h2><ol>
<li>索引</li>
<li>字段类型（mapping）</li>
<li>文档（documents）</li>
<li>分片（倒排索引）</li>
</ol>
<blockquote>
<p>概述</p>
</blockquote>
<p>在前面的学习中，我们已经掌握了es是什么，同时也把es的服务安装启动，那么es是如何去存储数据，数据结构是什么，又是如何实现搜索的呢？我们先来聊聊ElasticSearch的相关概念</p>
<p>集群，节点，索引，文档，分片，映射是什么？</p>
<blockquote>
<p>elasticsearch是面向文档，关系行数据库和elasticsearch客观的对比 一切都是JSON</p>
</blockquote>
<table>
<thead>
<tr>
<th>Relational DB</th>
<th>ElasticSearch</th>
</tr>
</thead>
<tbody><tr>
<td>数据库（database）</td>
<td>索引（indices）</td>
</tr>
<tr>
<td>表（tables）</td>
<td>types</td>
</tr>
<tr>
<td>行（row）</td>
<td>documents</td>
</tr>
<tr>
<td>字段（columns）</td>
<td>fields</td>
</tr>
</tbody></table>
<p>elasticsearch（集群）中可以包含多个索引（数据库），每个索引中可以包含多个类型（表），每个类型下又包含多个文档（行），每个文档中又包含多个字段（列）。</p>
<h3 id="物理设计："><a href="#物理设计：" class="headerlink" title="物理设计："></a>物理设计：</h3><p>elasticsearch在后台把每个索引划分成多个分片，每分分片可以在集群中的不同服务器之间迁移</p>
<p>一个人就是一个集群！默认的集群名称就是elasticsearch</p>
<h3 id="逻辑设计："><a href="#逻辑设计：" class="headerlink" title="逻辑设计："></a>逻辑设计：</h3><p>一个索引类型中，包含多个文档，比如说文档1，文档2.当我们索引一篇文档时，可以通过这样的一个顺序找到它：索引 –&gt; 类型</p>
<p>–&gt; 文档ID，通过这个组合我们就能索引到某个具体的文档。 注意：ID不必是整数，实际上它是个字符串</p>
<blockquote>
<p>文档</p>
</blockquote>
<p>之前说elasticsearch是<strong>面向文档</strong>的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch中，文档有几个重要的属性：</p>
<ul>
<li>自我包含，一篇文档同时包含字段和对应的值，也就是同时包含key：value</li>
<li>可以使层次性的，一个文档中包含自文档，复杂的逻辑实体就是这么来的</li>
<li>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段</li>
</ul>
<p>尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整型，因为elasticsearch或保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型。</p>
<blockquote>
<p>类型</p>
</blockquote>
<p>类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。类型中对于字段的定义称为映射，比如name映射为字符串类型。我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么elasticsearch是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch会认为它是整形。但是elasticsearch也可能猜不对，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别整什么幺蛾子。</p>
<blockquote>
<p>索引</p>
</blockquote>
<p>就是数据库!</p>
<p>索引是映射类型的容器，elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的。</p>
<h3 id="物理设计-节点和分片如何工作"><a href="#物理设计-节点和分片如何工作" class="headerlink" title="物理设计:节点和分片如何工作"></a>物理设计:节点和分片如何工作</h3><p>![F__M<del>L9XG___</del>8AB4AL1T`R.png](<a href="https://i.loli.net/2020/12/14/7cvhD91iE2APlQg.png">https://i.loli.net/2020/12/14/7cvhD91iE2APlQg.png</a>)</p>
<p>一个集群至少有一个节点，而一个节点就是一个elasricsearch进程，节点可以有多个索引默认的，节点可以有多个索引默认的有个5个分片( primary shard ,又称主分片)构成的，每一个主分片会有一个副本( replica shard ,又称复制分片)</p>
<p><img src="https://i.loli.net/2020/12/14/QY1g4R6nbHtGkz5.png" alt="AU_7EN_R@__EPT_O__VA2BG.png"></p>
<p>图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内，这样有利于某个节点挂掉了，数据也不至于丢失。实际上，一个分片是一个Lucene索引，一个包含倒排索引的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。</p>
<blockquote>
<p>倒排索引</p>
</blockquote>
<p>elasticsearch使用的是一种称为倒排索引的结构，采用Lucene倒排索作为底层。这种结构适用于快速的全文搜索，一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。例如，现在有两个文档，每个文档包含如下内容:</p>
<p>![QX_U_4Z5J`YOJ21L_Z~AFQP.png](<a href="https://i.loli.net/2020/12/14/VpP4CjEOWaS3niQ.png">https://i.loli.net/2020/12/14/VpP4CjEOWaS3niQ.png</a>)</p>
<p>现在，我们试图搜索to forever，只需要查看包含每个词条的文档</p>
<p><img src="https://i.loli.net/2020/12/14/S54qxGoL2OraZU1.png" alt="1T_ZH_BJ@OPJJPGM_DYR_BB.png"></p>
<p>两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，现在，这两个包含关键字的文档都将返回。再来看一个示例，比如我们通过博客标签来搜索博客文章。那么倒排索引列表就是这样的一个结构:</p>
<p>![_ZYFKG1Y4CYD_`Z@G0CH4_H.png](<a href="https://i.loli.net/2020/12/14/nGX4iIKVeY25CzE.png">https://i.loli.net/2020/12/14/nGX4iIKVeY25CzE.png</a>)</p>
<p>如果要搜索含有python标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要-查看标签这一栏，然后获取相关的文章ID即可。完全过滤掉无关的数据，提高效率！</p>
<p>在elasticsearch中，索引（库）这个词被频繁使用。在elasticsearch中，索引被分为多个分片，每份分片是一个Lucene的索引。所以一个elasticsearch索引是由多个Lucene索引组成的。别问为什么，谁让elasticsearch使用Lucene作为底层呢!如无特指，说起索引都是指elasticsearch的索引。</p>
<p>接下来的一切操作都在kibana中Dev Tools下的Console里完成。基础操作!</p>
<h3 id="Rest风格说明"><a href="#Rest风格说明" class="headerlink" title="Rest风格说明"></a><strong>Rest风格说明</strong></h3><p>一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格</p>
<p>设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>基本Rest命令说明∶</p>
<table>
<thead>
<tr>
<th>method</th>
<th>url地址</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PUT</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>创建文档（指定文档id )</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200/索引名称/类型名称</td>
<td>创建文档（随机文档id )</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200/索引名称/类型名称/文档id/_update</td>
<td>修改文档</td>
</tr>
<tr>
<td>DELETE</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>删除文档</td>
</tr>
<tr>
<td>GET</td>
<td>localhost:9200/索引名称/类型名称/文档id</td>
<td>查询文档通过文档id</td>
</tr>
<tr>
<td>POST</td>
<td>localhost:9200/索引名称/类型名称/search</td>
<td>查询所有数据</td>
</tr>
</tbody></table>
<h4 id="关于索引的基本操作"><a href="#关于索引的基本操作" class="headerlink" title="关于索引的基本操作"></a>关于索引的基本操作</h4><blockquote>
<p>基础测试</p>
</blockquote>
<ol>
<li>创建一个索引</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;索引名&#x2F;~类型名~&#x2F;文档id</span><br><span class="line">&#123;请求体&#125;</span><br></pre></td></tr></table></figure>

<p>![Y__E@TCELVRW_Z`F1_RI__V.png](<a href="https://i.loli.net/2020/12/14/ia6oQsTOPgvDf8M.png">https://i.loli.net/2020/12/14/ia6oQsTOPgvDf8M.png</a>)</p>
<p>2.完成自动增加索引 数据也成功添加了</p>
<p><img src="https://i.loli.net/2020/12/14/obIHKL2gdW4eixA.png" alt="S`_8EX__F_F__7QHR_0~G`H.png"></p>
<p>3.那么name 字段用不用指定类型呢。毕竟我们关系型数据库，是需要指定类型的啊</p>
<ul>
<li><p>字符串类型</p>
<p>text、keyword</p>
</li>
<li><p>数值类型</p>
<p>long、integer、short、byte、double、float、half float、scaled float</p>
</li>
<li><p>日期类型</p>
<p>date</p>
</li>
<li><p>te布尔类型</p>
<p>boolean</p>
</li>
<li><p>二进制类型</p>
<p>binary</p>
</li>
<li><p>等等…</p>
</li>
</ul>
<p>4.指定字段的类型</p>
<p>![2_DTS`1@W2I_D__P__J__XJ.png](<a href="https://i.loli.net/2020/12/14/cpiMvoDfLUt1kls.png">https://i.loli.net/2020/12/14/cpiMvoDfLUt1kls.png</a>)</p>
<p>获得这个规则，可以通过 GET请求获取具体的信息</p>
<p><img src="https://i.loli.net/2020/12/14/6cNjAWEMSL1PiHF.png" alt="TN8_F3O2QQ__HPMEIE7__HG.png"></p>
<p>5.查看默认的信息</p>
<p><img src="https://i.loli.net/2020/12/14/8yprjhQS56wRxNX.png" alt="3~A5BWPE4N8_VVIEZ5D@_C4.png"></p>
<p>如果自己的文档字段没有指定，那么es就会给我们默认配置字段类型（如“keyword”）<br>扩展： 通过命令 elasticsearch 索引情况！通过get _cat/ 可以获得es的当前的很多信息</p>
<p>修改方式：post：——update</p>
<p><img src="https://i.loli.net/2020/12/14/VIH8pad3gcKEwhO.png" alt="KNN_8__G_ZXB~9__DN_6DIT.png"></p>
<blockquote>
<p>删除索引</p>
</blockquote>
<p>通过DELETE命令实现删除，根据的请求来判断是删除索引还是删除文档记录</p>
<p>使用RESTFUL 分割使我们ES推荐给大家使用的</p>
<h4 id="关于文档的基本操作（重点）"><a href="#关于文档的基本操作（重点）" class="headerlink" title="关于文档的基本操作（重点）"></a>关于文档的基本操作（重点）</h4><ol>
<li><p>创建数据</p>
<p>![9G`BBH5B_@OIH_M89_____Y.png](<a href="https://i.loli.net/2020/12/14/EO4iaHsA3NMRwIG.png">https://i.loli.net/2020/12/14/EO4iaHsA3NMRwIG.png</a>)</p>
</li>
<li><p>获取数据GET</p>
</li>
<li><p><img src="https://i.loli.net/2020/12/14/iQGpnNBDsxMbZkr.png" alt="DV6@_L97DMNAPH05CF_DN4S.png"></p>
</li>
</ol>
<p>3.更新数据 PUT</p>
<p><img src="https://i.loli.net/2020/12/14/bIpsx6oQTR4JOZM.png" alt="UNR64C6SCH~_AOSQ8_QU_V1.png"></p>
<ol start="4">
<li>Post _update,推荐视同这种更新方式（put不传值的话会被覆盖）</li>
</ol>
<p>![7L_@___HF5J__YA_M7~D_`2.png](<a href="https://i.loli.net/2020/12/14/duUFtTpOL1iaqHm.png">https://i.loli.net/2020/12/14/duUFtTpOL1iaqHm.png</a>)</p>
<blockquote>
<p>简单的搜索</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET qy&#x2F;user&#x2F;1</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/12/14/b4SVICtmH6w9Lq3.png" alt="_OPHEB_Z34__A1__ZHF51TM.png"></p>
<blockquote>
<p>复杂操作搜索（select（排序，分页，高亮，模糊查询，精准查询））</p>
</blockquote>
<p>![CEL_ZYASI_C4WIJ6K`T___J.png](<a href="https://i.loli.net/2020/12/14/HdOmbTrlNpxQFoY.png">https://i.loli.net/2020/12/14/HdOmbTrlNpxQFoY.png</a>)</p>
<p><img src="https://i.loli.net/2020/12/14/AUKe9wFoEMY4BnZ.png" alt="L__MQ8D~C@RMO_ZKWLJJW88.png"></p>
<p><img src="https://i.loli.net/2020/12/14/9ojdZyWsh4V5vSL.png" alt="6S3__OTAZ~_EXS37OED7W5B.png"></p>
<blockquote>
<p>排序</p>
</blockquote>
<p><img src="https://i.loli.net/2020/12/14/1tREYT7z4kQAeol.png" alt="05_K__3QC~_5ZW_X_AP@I9U.png"></p>
<blockquote>
<p>分页查询</p>
</blockquote>
<p><img src="https://i.loli.net/2020/12/14/H7KDrp52A9Nzbai.png" alt="_SH3J1CZLGZ_@__O~5T_@_O.png"></p>
<p>数据下标还是从0开始，和学的所有数据结构是一样的</p>
<p>/search/{current}/{pagesize}</p>
<blockquote>
<p>布尔值查询</p>
</blockquote>
<p>must（and），所有的条件都要符合，where id = 1 and name = xxx</p>
<p><img src="https://i.loli.net/2020/12/14/drB1q4LbRWvh2Ox.png" alt="X33SK0V7VEY21ZR_QN7@IBJ.png"></p>
<p>should（or），所有的条件都要符合，where id = 1 or name = xxx</p>
<p><img src="https://i.loli.net/2020/12/14/aCtWn4FfEDL6Z2G.png" alt="5G4__UM23OU6D9_G_W2_9C0.png"></p>
<p>must_not(not)</p>
<p><img src="https://i.loli.net/2020/12/14/btukzQ2ZR4qeaFU.png" alt="PPL_W_9TK__6U_X_KV8O9TY.png"></p>
<p>过滤器</p>
<p><img src="https://i.loli.net/2020/12/14/mtPcrq78NhOzvsy.png" alt="JN9Y10_7J9UBM@4_7DCN5YF.png"></p>
<ul>
<li>gt 大于</li>
<li>gte 大于等于</li>
<li>lt 小于</li>
<li>lte 小于等于</li>
</ul>
<blockquote>
<p>匹配多个条件</p>
</blockquote>
<p><img src="https://i.loli.net/2020/12/14/FiMtXCAKWZmfabN.png" alt="_SV_YWXV_H2ZV8DR_1_IWEN.png"></p>
<blockquote>
<p>精确查询</p>
</blockquote>
<p>term 查询是直接通过倒排索引指定的词条进行精确查找的</p>
<p>关于分词</p>
<ul>
<li>term 直接查询精确值</li>
<li>match，会使用分词器解析！ （先分析文档，然后在通过分析的文档进行查询）</li>
</ul>
<p><strong>两个类型 text keyword</strong></p>
<p>![I__E_2__S2__H@6CQ1VH`VU.png](<a href="https://i.loli.net/2020/12/14/5yJGkZeLCqwM7QE.png">https://i.loli.net/2020/12/14/5yJGkZeLCqwM7QE.png</a>)</p>
<p><img src="https://i.loli.net/2020/12/14/rZCkOwdta1FLlWB.png" alt="4L5RKL_~_~__RTDS7U__I2Q.png"></p>
<p><strong>keyword字段类型不会被分词器解析</strong></p>
<blockquote>
<p>多个值匹配的精确查询</p>
</blockquote>
<p><img src="https://i.loli.net/2020/12/14/X75wInNJs3eV4rA.png" alt="Y4F3QBC_FDW9BEK_TX4R_LG.png"></p>
<blockquote>
<p>高亮查询</p>
</blockquote>
<p><img src="https://i.loli.net/2020/12/14/qy5AoBYiJenGhsk.png" alt="H6GN303_X1_7G_LYH_Q24_8.png"></p>
<h2 id="七、IK分词器插件"><a href="#七、IK分词器插件" class="headerlink" title="七、IK分词器插件"></a>七、IK分词器插件</h2><blockquote>
<p>什么是IK分词器？</p>
</blockquote>
<p>分词:即把一段中文或者别的划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，比如“我爱狂神”会被分为”我”“爱”狂”“神””，这显然是不符合要求的，所以我们需要安装中文分词器ik来解决这个问题。</p>
<p>IK提供了两个分词算法: ik_smart（最少切分）和ik_max_word（最细粒度切分）</p>
<p>1.下载：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p>
<p>2.下载完毕后放入es插件中即可</p>
<p>3.重启es</p>
<p>4.elasticsearch-plugin命令来查看使用</p>
<p>5.使用kibana进行测试</p>
<p>ik_smart（最少切分）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">  , &quot;text&quot;: &quot;中国共产党&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;中国共产党&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ik_max_word（最细粒度切分）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">  , &quot;text&quot;: &quot;中国共产党&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;中国共产党&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;中国&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;国共&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 1,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;共产党&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;共产&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 4,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;党&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 4,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 5</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义：</strong>在es的IK分词器的congfig中自定义dic文件再配置到xml中即可</p>
<h2 id="八、集成SpringBoot"><a href="#八、集成SpringBoot" class="headerlink" title="八、集成SpringBoot"></a>八、集成SpringBoot</h2><p>导入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">		&lt;!-- 自定义es版本依赖--&gt;</span><br><span class="line">		&lt;elasticsearch.version&gt;7.6.1&lt;&#x2F;elasticsearch.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;configuration&gt;</span><br><span class="line">					&lt;excludes&gt;</span><br><span class="line">						&lt;exclude&gt;</span><br><span class="line">							&lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">							&lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">						&lt;&#x2F;exclude&gt;</span><br><span class="line">					&lt;&#x2F;excludes&gt;</span><br><span class="line">				&lt;&#x2F;configuration&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class QyEsQpiApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	@Qualifier(&quot;restHighLevelClient&quot;)</span><br><span class="line">	private RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;创建索引</span><br><span class="line">	@Test</span><br><span class="line">	void testCreateIndex() throws IOException &#123;</span><br><span class="line">		&#x2F;&#x2F;创建索引请求</span><br><span class="line">		CreateIndexRequest request &#x3D; new CreateIndexRequest(&quot;qy_index&quot;);</span><br><span class="line">		&#x2F;&#x2F;执行创建请求</span><br><span class="line">		CreateIndexResponse createIndexResponse &#x3D;</span><br><span class="line">				client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">		System.out.println(createIndexResponse);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;获取索引</span><br><span class="line">	@Test</span><br><span class="line">	void testExistIndex() throws IOException &#123;</span><br><span class="line">		GetIndexRequest request &#x3D; new GetIndexRequest(&quot;qy_index&quot;);</span><br><span class="line">		boolean exists &#x3D; client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">		System.out.println(exists);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;删除索引</span><br><span class="line">	@Test</span><br><span class="line">	void testDeleteIndex() throws IOException &#123;</span><br><span class="line">		DeleteIndexRequest request &#x3D; new DeleteIndexRequest(&quot;qy_index&quot;);</span><br><span class="line">		AcknowledgedResponse delete &#x3D; client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">		System.out.println(delete.isAcknowledged());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体的api 测试</p>
</blockquote>
<ol>
<li>创建索引</li>
<li>获取索引</li>
<li>删除索引</li>
<li>操作文档</li>
<li>crud文档</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;测试添加文档</span><br><span class="line">	@Test</span><br><span class="line">	void testAddDocument() throws IOException &#123;</span><br><span class="line">		&#x2F;&#x2F;创建对象</span><br><span class="line">		User user &#x3D; new User(&quot;qy&quot;,3);</span><br><span class="line">		&#x2F;&#x2F;创建请求</span><br><span class="line">		IndexRequest request &#x3D; new IndexRequest(&quot;qy_index&quot;);</span><br><span class="line">		&#x2F;&#x2F;规则 put&#x2F;qy_index&#x2F;_doc&#x2F;1</span><br><span class="line">		request.id(&quot;1&quot;);</span><br><span class="line">		request.timeout(&quot;1s&quot;);</span><br><span class="line">		&#x2F;&#x2F;将我们的数据放入请求</span><br><span class="line">		request.source(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line">		&#x2F;&#x2F;客户端发出去</span><br><span class="line">		IndexResponse index &#x3D; client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">		System.out.println(index.toString());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>ElasticSearch相关</category>
      </categories>
      <tags>
        <tag>es</tag>
      </tags>
  </entry>
  <entry>
    <title>Springcloud框架整合</title>
    <url>/qyaaaa.github.io/2020/08/10/springcloud/</url>
    <content><![CDATA[<h1 id="Springcloud"><a href="#Springcloud" class="headerlink" title="Springcloud"></a>Springcloud</h1><blockquote>
<p>学习自狂神说:<a href="https://www.bilibili.com/video/BV1F5411J7vK">https://www.bilibili.com/video/BV1F5411J7vK</a></p>
<p><strong>代码：<a href="https://gitee.com/qyaa/MySpringCloud">https://gitee.com/qyaa/MySpringCloud</a></strong></p>
</blockquote>
<h2 id="一、什么是微服务？"><a href="#一、什么是微服务？" class="headerlink" title="一、什么是微服务？"></a>一、什么是微服务？</h2><blockquote>
<p>什么是微服务？</p>
</blockquote>
<p>微服务(Microservice Architecture) 是近几年流行的一种架构思想，关于它的概念很难一言以蔽之。</p>
<p>究竟什么是微服务呢？我们在此引用ThoughtWorks 公司的首席科学家 Martin Fowler 于2014年提出的一段话：</p>
<p>汉化：<a href="https://www.cnblogs.com/liuning8023/p/4493156.html">https://www.cnblogs.com/liuning8023/p/4493156.html</a></p>
<ul>
<li>就目前而言，对于微服务，业界并没有一个统一的，标准的定义。</li>
<li>但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，<strong>它体长将单一的应用程序划分成一组小的服务</strong>，每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(<strong>HTTP</strong>)互相沟通，每个服务都围绕着具体的业务进行构建，并且能狗被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(<strong>Maven</strong>)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。</li>
</ul>
<blockquote>
<p>再来从技术维度角度理解下：</p>
</blockquote>
<ul>
<li>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</li>
</ul>
<h2 id="二、-微服务技术栈有那些？"><a href="#二、-微服务技术栈有那些？" class="headerlink" title="二、 微服务技术栈有那些？"></a>二、 微服务技术栈有那些？</h2><table>
<thead>
<tr>
<th><strong>微服务技术条目</strong></th>
<th>落地技术</th>
</tr>
</thead>
<tbody><tr>
<td>服务开发</td>
<td>SpringBoot、Spring、SpringMVC等</td>
</tr>
<tr>
<td>服务配置与管理</td>
<td>Netfix公司的Archaius、阿里的Diamond等</td>
</tr>
<tr>
<td>服务注册与发现</td>
<td>Eureka、Consul、Zookeeper等</td>
</tr>
<tr>
<td>服务调用</td>
<td>Rest、PRC、gRPC</td>
</tr>
<tr>
<td>服务熔断器</td>
<td>Hystrix、Envoy等</td>
</tr>
<tr>
<td>负载均衡</td>
<td>Ribbon、Nginx等</td>
</tr>
<tr>
<td>服务接口调用(客户端调用服务的简化工具)</td>
<td>Fegin等</td>
</tr>
<tr>
<td>消息队列</td>
<td>Kafka、RabbitMQ、ActiveMQ、RocketMQ等</td>
</tr>
<tr>
<td>服务配置中心管理</td>
<td>SpringCloudConfig、Chef等</td>
</tr>
<tr>
<td>服务路由(API网关)</td>
<td>Zuul等</td>
</tr>
<tr>
<td>服务监控</td>
<td>Zabbix、Nagios、Metrics、Specatator等</td>
</tr>
<tr>
<td>全链路追踪</td>
<td>Zipkin、Brave、Dapper等</td>
</tr>
<tr>
<td>数据流操作开发包</td>
<td>SpringCloud Stream(封装与Redis，Rabbit，Kafka等发送接收消息)</td>
</tr>
<tr>
<td>时间消息总栈</td>
<td>SpringCloud Bus</td>
</tr>
<tr>
<td>服务部署</td>
<td>Docker、OpenStack、Kubernetes等各微服务框架对比</td>
</tr>
</tbody></table>
<h2 id="三、各微服务框架对比"><a href="#三、各微服务框架对比" class="headerlink" title="三、各微服务框架对比"></a>三、各微服务框架对比</h2><table>
<thead>
<tr>
<th><strong>功能点/服务框架</strong></th>
<th>Netflix/SpringCloud</th>
<th>Motan</th>
<th>gRPC</th>
<th>Thri t</th>
<th>Dubbo/DubboX</th>
</tr>
</thead>
<tbody><tr>
<td>功能定位</td>
<td>完整的微服务框架</td>
<td>RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册发现</td>
<td>RPC框架</td>
<td>RPC框架</td>
<td>服务框架</td>
</tr>
<tr>
<td>支持Rest</td>
<td>是，Ribbon支持多种可拔插的序列号选择</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>支持RPC</td>
<td>否</td>
<td>是(Hession2)</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>支持多语言</td>
<td>是(Rest形式)</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>负载均衡</td>
<td>是(服务端zuul+客户端Ribbon)，zuul-服务，动态路由，云端负载均衡Eureka（针对中间层服务器）</td>
<td>是(客户端)</td>
<td>否</td>
<td>否</td>
<td>是(客户端)</td>
</tr>
<tr>
<td>配置服务</td>
<td>Netfix Archaius，Spring Cloud Config Server 集中配置</td>
<td>是(Zookeeper提供)</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>服务调用链监控</td>
<td>是(zuul)，zuul提供边缘服务，API网关</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>高可用/容错</td>
<td>是(服务端Hystrix+客户端Ribbon)</td>
<td>是(客户端)</td>
<td>否</td>
<td>否</td>
<td>是(客户端)</td>
</tr>
<tr>
<td>典型应用案例</td>
<td>Netflix</td>
<td>Sina</td>
<td>Google</td>
<td>Facebook</td>
<td></td>
</tr>
<tr>
<td>社区活跃程度</td>
<td>高</td>
<td>一般</td>
<td>高</td>
<td>一般</td>
<td>2017年后重新开始维护，之前中断了5年</td>
</tr>
<tr>
<td>学习难度</td>
<td>中等</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>文档丰富程度</td>
<td>高</td>
<td>一般</td>
<td>一般</td>
<td>一般</td>
<td>高</td>
</tr>
<tr>
<td>其他</td>
<td>Spring Cloud Bus为我们的应用程序带来了更多管理端点</td>
<td>支持降级</td>
<td>Netflix内部在开发集成gRPC</td>
<td>IDL定义</td>
<td>实践的公司比较多</td>
</tr>
</tbody></table>
<h2 id="四、-SpringCloud和SpringBoot的关系"><a href="#四、-SpringCloud和SpringBoot的关系" class="headerlink" title="四、 SpringCloud和SpringBoot的关系"></a><strong>四、 SpringCloud和SpringBoot的关系</strong></h2><ul>
<li>SpringBoot专注于开苏方便的开发单个个体微服务；</li>
<li>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、为代理、事件总栈、全局锁、决策竞选、分布式会话等等集成服务；</li>
<li>SpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系；</li>
<li>SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架；</li>
</ul>
<h2 id="五、自学参考书："><a href="#五、自学参考书：" class="headerlink" title="五、自学参考书："></a><strong>五、自学参考书：</strong></h2><ul>
<li>SpringCloud Netflix 中文文档：<a href="https://springcloud.cc/spring-cloud-netflix.html">https://springcloud.cc/spring-cloud-netflix.html</a></li>
<li>SpringCloud 中文API文档(官方文档翻译版)：<a href="https://springcloud.cc/spring-cloud-dalston.html">https://springcloud.cc/spring-cloud-dalston.html</a></li>
<li>SpringCloud中国社区：<a href="http://springcloud.cn/">http://springcloud.cn/</a></li>
<li>SpringCloud中文网：<a href="https://springcloud.cc/">https://springcloud.cc</a></li>
</ul>
<h2 id="六、依赖"><a href="#六、依赖" class="headerlink" title="六、依赖"></a>六、依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--打包方式 --&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">        &lt;junit.version&gt;4.12&lt;&#x2F;junit.version&gt;</span><br><span class="line">        &lt;log4j.version&gt;1.2.17&lt;&#x2F;log4j.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;!--springcloud依赖 --&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;Greenwich.SR1&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;!-- springboot依赖--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.1.4&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;!--数据库 --&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;8.0.21&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.1.12&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;!--springboot启动器 --&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;!--junit --&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;!-- log4j--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;log4j.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;logback-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.2.3&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<h2 id="七、-Eureka服务注册中心"><a href="#七、-Eureka服务注册中心" class="headerlink" title="七、 Eureka服务注册中心"></a>七、 Eureka服务注册中心</h2><h3 id="7-1-什么是Eureka（有瑞卡）"><a href="#7-1-什么是Eureka（有瑞卡）" class="headerlink" title="7.1 什么是Eureka（有瑞卡）"></a>7.1 什么是Eureka（有瑞卡）</h3><ul>
<li>Netflix在涉及Eureka时，遵循的就是API原则.</li>
<li>Eureka是Netflix的有个子模块，也是核心模块之一。Eureka是基于REST的服务，用于定位服务，以实现云端中间件层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心，比如Zookeeper.</li>
</ul>
<h3 id="7-2-原理理解"><a href="#7-2-原理理解" class="headerlink" title="7.2 原理理解"></a>7.2 原理理解</h3><ul>
<li><p><strong>Eureka基本的架构</strong></p>
<ul>
<li>Springcloud 封装了Netflix公司开发的Eureka模块来实现服务注册与发现 (对比Zookeeper).</li>
<li>Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心.</li>
<li>而系统中的其他微服务，使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，Springcloud 的一些其他模块 (比如Zuul) 就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑.</li>
</ul>
</li>
<li><p>Eureka 包含两个组件：<strong>Eureka Server</strong> 和 <strong>Eureka Client</strong>.</p>
</li>
<li><p>Eureka Server 提供服务注册，各个节点启动后，回在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会储存所有课用服务节点的信息，服务节点的信息可以在界面中直观的看到.</p>
</li>
<li><p>Eureka Client 是一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳 (默认周期为30秒) 。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除掉 (默认周期为90s).</p>
</li>
<li><p><strong>三大角色</strong></p>
<ul>
<li>Eureka Server：提供服务的注册与发现</li>
<li>Service Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能狗找到</li>
<li>Service Consumer：服务消费方，从Eureka中获取注册服务列表，从而找到消费服务</li>
</ul>
</li>
</ul>
<h3 id="7-3-EureKa自我保护机制：好死不如赖活着"><a href="#7-3-EureKa自我保护机制：好死不如赖活着" class="headerlink" title="7.3. EureKa自我保护机制：好死不如赖活着"></a>7.3. EureKa自我保护机制：好死不如赖活着</h3><p>一句话总结就是：<strong>某时刻某一个微服务不可用，eureka不会立即清理，依旧会对该微服务的信息进行保存！</strong></p>
<ul>
<li>默认情况下，当eureka server在一定时间内没有收到实例的心跳，便会把该实例从注册表中删除（<strong>默认是90秒</strong>），但是，如果短时间内丢失大量的实例心跳，便会触发eureka server的自我保护机制，比如在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启（因为在开发过程中不会修改eureka注册中心），<strong>当一分钟内收到的心跳数大量减少时，会触发该保护机制</strong>。可以在eureka管理界面看到Renews threshold和Renews(last min)，当后者（最后一分钟收到的心跳数）小于前者（心跳阈值）的时候，触发保护机制，会出现红色的警告：<code>EMERGENCY!EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#39;RE NOT.RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEGING EXPIRED JUST TO BE SAFE.</code>从警告中可以看到，eureka认为虽然收不到实例的心跳，但它认为实例还是健康的，eureka会保护这些实例，不会把它们从注册表中删掉。</li>
<li>该保护机制的目的是避免网络连接故障，在发生网络故障时，微服务和注册中心之间无法正常通信，但服务本身是健康的，不应该注销该服务，如果eureka因网络故障而把微服务误删了，那即使网络恢复了，该微服务也不会重新注册到eureka server了，因为只有在微服务启动的时候才会发起注册请求，后面只会发送心跳和服务列表请求，这样的话，该实例虽然是运行着，但永远不会被其它服务所感知。所以，eureka server在短时间内丢失过多的客户端心跳时，会进入自我保护模式，该模式下，eureka会保护注册表中的信息，不在注销任何微服务，当网络故障恢复后，eureka会自动退出保护模式。自我保护模式可以让集群更加健壮。</li>
<li>但是我们在开发测试阶段，需要频繁地重启发布，如果触发了保护机制，则旧的服务实例没有被删除，这时请求有可能跑到旧的实例中，而该实例已经关闭了，这就导致请求错误，影响开发测试。所以，在开发测试阶段，我们可以把自我保护模式关闭，只需在eureka server配置文件中加上如下配置即可：<code>eureka.server.enable-self-preservation=false</code>【不推荐关闭自我保护机制】</li>
</ul>
<h3 id="7-4-Eureka：集群环境配置"><a href="#7-4-Eureka：集群环境配置" class="headerlink" title="7.4 Eureka：集群环境配置"></a>7.4 Eureka：集群环境配置</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><p>新建springcloud-eureka-7002、springcloud-eureka-7003 模块</p>
<p>1.为pom.xml添加依赖 (与springcloud-eureka-7001相同)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-server --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 热部署工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.application.yml配置(与springcloud-eureka-7001相同)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span> <span class="comment">#7002，7003</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Eureka配置</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment"># 服务器的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#是否注册自己</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>

<p>3.主启动类(与springcloud-eureka-7001相同)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span><span class="comment">//服务端的启动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaService_7001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaService_7001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-集群成员相互关联"><a href="#2-集群成员相互关联" class="headerlink" title="2.集群成员相互关联"></a>2.集群成员相互关联</h4><p>C:\Windows\System32\drivers\etc中配置hosts</p>
<h3 id="7-5-对比和Zookeeper区别"><a href="#7-5-对比和Zookeeper区别" class="headerlink" title="7.5 对比和Zookeeper区别"></a>7.5 对比和Zookeeper区别</h3><h4 id="1-回顾CAP原则"><a href="#1-回顾CAP原则" class="headerlink" title="1. 回顾CAP原则"></a><strong>1. 回顾CAP原则</strong></h4><p>RDBMS (MySQL\Oracle\sqlServer) ===&gt; ACID</p>
<p>NoSQL (Redis\MongoDB) ===&gt; CAP</p>
<h4 id="2-CAP是什么"><a href="#2-CAP是什么" class="headerlink" title="2. CAP是什么?"></a><strong>2. CAP是什么?</strong></h4><ul>
<li>C (Consistency) 强一致性</li>
<li>A (Availability) 可用性</li>
<li>P (Partition tolerance) 分区容错性</li>
</ul>
<p>CAP的三进二：CA、AP、CP</p>
<h4 id="3-CAP理论的核心"><a href="#3-CAP理论的核心" class="headerlink" title="3. CAP理论的核心"></a><strong>3. CAP理论的核心</strong></h4><ul>
<li>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求</li>
<li>根据CAP原理，将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类<ul>
<li>CA：单点集群，满足一致性，可用性的系统，通常可扩展性较差</li>
<li>CP：满足一致性，分区容错的系统，通常性能不是特别高</li>
<li>AP：满足可用性，分区容错的系统，通常可能对一致性要求低一些</li>
</ul>
</li>
</ul>
<h4 id="4-作为分布式服务注册中心，Eureka比Zookeeper好在哪里？"><a href="#4-作为分布式服务注册中心，Eureka比Zookeeper好在哪里？" class="headerlink" title="4. 作为分布式服务注册中心，Eureka比Zookeeper好在哪里？"></a><strong>4. 作为分布式服务注册中心，Eureka比Zookeeper好在哪里？</strong></h4><p>著名的CAP理论指出，一个分布式系统不可能同时满足C (一致性) 、A (可用性) 、P (容错性)，由于分区容错性P再分布式系统中是必须要保证的，因此我们只能再A和C之间进行权衡。</p>
<ul>
<li>Zookeeper 保证的是 CP —&gt; 满足一致性，分区容错的系统，通常性能不是特别高</li>
<li>Eureka 保证的是 AP —&gt; 满足可用性，分区容错的系统，通常可能对一致性要求低一些</li>
</ul>
<p><strong>Zookeeper保证的是CP</strong></p>
<blockquote>
<p> 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接收服务直接down掉不可用。也就是说，<strong>服务注册功能对可用性的要求要高于一致性</strong>。但zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举<strong>（类似于哨兵模式？）</strong>。问题在于，选举leader的时间太长，30-120s，且选举期间整个zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题使得zookeeper集群失去master节点是较大概率发生的事件，虽然服务最终能够恢复，但是，漫长的选举时间导致注册长期不可用，是不可容忍的。</p>
</blockquote>
<p><strong>Eureka保证的是AP</strong></p>
<p> Eureka看明白了这一点，因此在设计时就优先保证可用性。<strong>Eureka各个节点都是平等的</strong>，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的信息可能不是最新的，除此之外，Eureka还有之中自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p>
<ul>
<li>Eureka不在从注册列表中移除因为长时间没收到心跳而应该过期的服务</li>
<li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上 (即保证当前节点依然可用)</li>
<li>当网络稳定时，当前实例新的注册信息会被同步到其他节点中</li>
</ul>
<p><strong>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪</strong></p>
<h2 id="八、-Ribbon：负载均衡-基于客户端"><a href="#八、-Ribbon：负载均衡-基于客户端" class="headerlink" title="八、 Ribbon：负载均衡(基于客户端)"></a>八、 Ribbon：负载均衡(基于客户端)</h2><h3 id="8-1-负载均衡以及Ribbon（瑞本）"><a href="#8-1-负载均衡以及Ribbon（瑞本）" class="headerlink" title="8.1 负载均衡以及Ribbon（瑞本）"></a>8.1 负载均衡以及Ribbon（瑞本）</h3><blockquote>
<p>Ribbon是什么？</p>
</blockquote>
<ul>
<li>Spring Cloud Ribbon 是基于Netflix Ribbon 实现的一套<strong>客户端负载均衡的工具</strong>。</li>
<li>简单的说，Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 的客户端组件提供一系列完整的配置项，如：连接超时、重试等。简单的说，就是在配置文件中列出 LoadBalancer (简称LB：负载均衡) 后面所有的及其，Ribbon 会自动的帮助你基于某种规则 (如简单轮询，随机连接等等) 去连接这些机器。我们也容易使用 Ribbon 实现自定义的负载均衡算法！</li>
</ul>
<blockquote>
<p>Ribbon能干嘛？</p>
</blockquote>
<ul>
<li>LB，即负载均衡 (LoadBalancer) ，在微服务或分布式集群中经常用的一种应用。</li>
<li>负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高用)。</li>
<li>常见的负载均衡软件有 Nginx、Lvs 、Apache+Tomcat等等。</li>
<li>Dubbo、SpringCloud 中均给我们提供了负载均衡，<strong>SpringCloud 的负载均衡算法可以自定义</strong>。</li>
<li>负载均衡简单分类：<ul>
<li>集中式LB<ul>
<li>即在服务的提供方和消费方之间使用独立的LB设施，如**Nginx(反向代理服务器)**，由该设施负责把访问请求通过某种策略转发至服务的提供方！</li>
</ul>
</li>
<li>进程式 LB<ul>
<li>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。</li>
<li><strong>Ribbon 就属于进程内LB</strong>，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-2演示图"><a href="#8-2演示图" class="headerlink" title="8.2演示图"></a>8.2演示图</h3><p><strong>查询时进行轮询查询</strong></p>
<p><img src="https://i.loli.net/2020/12/12/BDnFLCiTrWVoOlU.png" alt="未命名文件.png"></p>
<h2 id="九、Feign：负载均衡-基于服务端"><a href="#九、Feign：负载均衡-基于服务端" class="headerlink" title="九、Feign：负载均衡(基于服务端)"></a>九、Feign：负载均衡(基于服务端)</h2><h3 id="9-1-Feign简介"><a href="#9-1-Feign简介" class="headerlink" title="9.1 Feign简介"></a>9.1 Feign简介</h3><p>Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Ribbon和Eureka，可以使用Feigin提供负载均衡的http客户端</p>
<p><strong>只需要创建一个接口，然后添加注解即可~</strong></p>
<p>Feign，主要是社区版，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法</p>
<ol>
<li>微服务名字 【ribbon】</li>
<li>接口和注解 【feign】</li>
</ol>
<p><strong>Feign能干什么？</strong></p>
<ul>
<li>Feign旨在使编写Java Http客户端变得更容易</li>
<li>前面在使用<strong>Ribbon</strong> + <strong>RestTemplate</strong>时，利用<strong>RestTemplate</strong>对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一个客户端类来包装这些依赖服务的调用。所以，<strong>Feign</strong>在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解)，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon 时，自动封装服务调用客户端的开发量。</li>
</ul>
<p><strong>Feign默认集成了Ribbon</strong></p>
<ul>
<li>利用<strong>Ribbon</strong>维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与<strong>Ribbon</strong>不同的是，通过<strong>Feign</strong>只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。</li>
</ul>
<h3 id="9-2配置"><a href="#9-2配置" class="headerlink" title="9.2配置"></a>9.2配置</h3><p>Feign依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Feign的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="十、Hystrix：服务熔断"><a href="#十、Hystrix：服务熔断" class="headerlink" title="十、Hystrix：服务熔断"></a>十、Hystrix：服务熔断</h2><p>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免失败！</p>
<h3 id="10-1-服务雪崩"><a href="#10-1-服务雪崩" class="headerlink" title="10.1 服务雪崩"></a>10.1 服务雪崩</h3><ul>
<li><p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”，如果扇出的链路上<strong>某个微服务的调用响应时间过长，或者不可用</strong>，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。</p>
</li>
<li><p>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几十秒内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障，<strong>这些都表示需要对故障和延迟进行隔离和管理，以达到单个依赖关系的失败而不影响整个应用程序或系统运行</strong>。</p>
</li>
<li><p>我们需要，<strong>弃车保帅</strong>！</p>
</li>
</ul>
<p>中间某一服务出问题，就会出现服务雪崩</p>
<p>  <img src="https://i.loli.net/2020/12/13/xmHKCjROtapPd6e.png" alt="未命名文件 _1_.png"></p>
<h3 id="10-2-什么是Hystrix？"><a href="#10-2-什么是Hystrix？" class="headerlink" title="10.2 什么是Hystrix？"></a>10.2 什么是Hystrix？</h3><p> <strong>Hystrix</strong>是一个应用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，<strong>Hystrix</strong> 能够保证在一个依赖出问题的情况下，不会导致整个体系服务失败，避免级联故障，以提高分布式系统的弹性。</p>
<p> “<strong>断路器</strong>”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控 (类似熔断保险丝) ，<strong>向调用方返回一个服务预期的，可处理的备选响应 (FallBack) ，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证了服务调用方的线程不会被长时间，不必要的占用</strong>，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<h3 id="10-3-Hystrix能干嘛？"><a href="#10-3-Hystrix能干嘛？" class="headerlink" title="10.3 Hystrix能干嘛？"></a>10.3 Hystrix能干嘛？</h3><ul>
<li>服务降级</li>
<li>服务熔断</li>
<li>服务限流</li>
<li>接近实时的监控</li>
<li>…</li>
</ul>
<h3 id="10-4-服务熔断"><a href="#10-4-服务熔断" class="headerlink" title="10.4 服务熔断"></a>10.4 服务熔断</h3><p><strong>什么是服务熔断?</strong></p>
<p> <strong>熔断机制是赌赢雪崩效应的一种微服务链路保护机制</strong>。</p>
<p> 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，<strong>进而熔断该节点微服务的调用，快速返回错误的响应信息</strong>。  检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阀值缺省是<strong>5秒内20次调用失败，就会启动熔断机制</strong>。熔断机制的注解是：<code>@HystrixCommand</code>。</p>
<p>服务熔断解决如下问题：</p>
<ul>
<li>当所依赖的对象不稳定时，能够起到快速失败的目的；</li>
<li>快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复。</li>
</ul>
<p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入Hystrix依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8001</span><br><span class="line"># mybatis配置</span><br><span class="line">mybatis:</span><br><span class="line">  type-aliases-package: com.qy.springcloud.pojo</span><br><span class="line">  config-location: classpath:mybatis&#x2F;mybatis-config.xml</span><br><span class="line">  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: springcloud-provider-dept</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db01?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: qiaoyu1055575039</span><br><span class="line"></span><br><span class="line"># Eureka配置</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7003.com:7003&#x2F;eureka&#x2F;</span><br><span class="line">    instance:</span><br><span class="line">      instance-id: springcloud-provider-dept-hystrix-8001</span><br><span class="line"></span><br><span class="line">info:</span><br><span class="line">  app.name: qy-springcloud</span><br><span class="line">  company.name: blog.qy.com</span><br></pre></td></tr></table></figure>

<h3 id="10-5-服务降级"><a href="#10-5-服务降级" class="headerlink" title="10.5 服务降级"></a>10.5 服务降级</h3><p><strong>什么是服务降级?</strong></p>
<p> 服务降级是指 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理，或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。说白了，<strong>就是尽可能的把系统资源让给优先级高的服务</strong>。</p>
<p>资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证核心功能服务的可用性，都要对某些服务降级处理。比如当双11活动时，把交易无关的服务统统降级，如查看蚂蚁深林，查看历史订单等等。</p>
<p>服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，可以将一些 不重要 或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用。</p>
<p>降级的方式可以根据业务来，可以延迟服务，比如延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行 ；或者在粒度范围内关闭服务，比如关闭相关文章的推荐。</p>
<p><strong>服务降级需要考虑的问题</strong></p>
<ul>
<li>1）那些服务是核心服务，哪些服务是非核心服务</li>
<li>2）那些服务可以支持降级，那些服务不能支持降级，降级策略是什么</li>
<li>3）除服务降级之外是否存在更复杂的业务放通场景，策略是什么？</li>
</ul>
<p><strong>自动降级分类</strong></p>
<p>1）超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况</p>
<p>2）失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况</p>
<p>3）故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）</p>
<p>4）限流降级：秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。</p>
<h3 id="10-6-服务熔断和降级的区别"><a href="#10-6-服务熔断和降级的区别" class="headerlink" title="10.6 服务熔断和降级的区别"></a>10.6 服务熔断和降级的区别</h3><ul>
<li><strong>服务熔断—&gt;服务端</strong>：某个服务超时或异常，引起熔断~，类似于保险丝(自我熔断)</li>
<li><strong>服务降级—&gt;客户端</strong>：从整体网站请求负载考虑，当某个服务熔断或者关闭之后，服务将不再被调用，此时在客户端，我们可以准备一个 FallBackFactory ，返回一个默认的值(缺省值)。会导致整体的服务下降，但是好歹能用，比直接挂掉强。</li>
<li>触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）</li>
<li>实现方式不太一样，服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为<strong>自我熔断</strong>。</li>
</ul>
<p><strong>熔断，降级，限流</strong>：</p>
<p>限流：限制并发的请求访问量，超过阈值则拒绝；</p>
<p>降级：服务分优先级，牺牲非核心服务（不可用），保证核心服务稳定；从整体负荷考虑；</p>
<p>熔断：依赖的下游服务故障触发熔断，避免引发本系统崩溃；系统自动执行和恢复</p>
<h3 id="10-7-Dashboard-流监控"><a href="#10-7-Dashboard-流监控" class="headerlink" title="10.7 Dashboard 流监控"></a>10.7 Dashboard 流监控</h3><p>新建springcloud-consumer-hystrix-dashboard模块</p>
<p><strong>添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">!--实体类+web --&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Hystrix依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--dashboard依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Ribbon --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.qy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springcloud-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 热部署工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.spotbugs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spotbugs-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>主启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qy.springcloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span><span class="comment">//开启监控</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptConsumerDashboard_9001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DeptConsumerDashboard_9001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十一、-Zull路由网关"><a href="#十一、-Zull路由网关" class="headerlink" title="十一、 Zull路由网关"></a>十一、 Zull路由网关</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>什么是zuul?</p>
</blockquote>
<p> Zull包含了对请求的<strong>路由</strong>(用来跳转的)和<strong>过滤</strong>两个最主要功能：</p>
<p> 其中<strong>路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础</strong>，而过<strong>滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础</strong>。Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。</p>
<p>依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!--导入zuul依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-zuul&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- Hystrix依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--dashboard依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--Ribbon --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.qy&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springcloud-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- 热部署工具--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.spotbugs&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spotbugs-annotations&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.9&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<h2 id="十二、-Spring-Cloud-Config-分布式配置"><a href="#十二、-Spring-Cloud-Config-分布式配置" class="headerlink" title="十二、 Spring Cloud Config 分布式配置"></a>十二、 Spring Cloud Config 分布式配置</h2><p><strong>Dalston.RELEASE</strong></p>
<p><strong>Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持</strong>。使用Config Server，您可以在所有环境中管理应用程序的外部属性。客户端和服务器上的概念映射与Spring <code>Environment</code>和<code>PropertySource</code>抽象相同，因此它们与Spring应用程序非常契合，但可以与任何以任何语言运行的应用程序一起使用。随着应用程序通过从开发人员到测试和生产的部署流程，您可以管理这些环境之间的配置，并确定应用程序具有迁移时需要运行的一切。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。很容易添加替代实现，并使用Spring配置将其插入。</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>分布式系统面临的–配置文件问题</strong></p>
<p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的，动态的配置管理设施是必不可少的。spring cloud提供了configServer来解决这个问题，我们每一个微服务自己带着一个application.yml，那上百个的配置文件修改起来，令人头疼！</p>
<p><strong>什么是SpringCloud config分布式配置中心？</strong></p>
<p>pring cloud config 为微服务架构中的微服务提供集中化的外部支持，配置服务器为各个不同微服务应用的所有环节提供了一个<strong>中心化的外部配置</strong>。</p>
<p> spring cloud config 分为<strong>服务端</strong>和<strong>客户端</strong>两部分。</p>
<p> 服务端也称为 <strong>分布式配置中心</strong>，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密，解密信息等访问接口。</p>
<p> 客户端则是<strong>通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息</strong>。配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可用通过git客户端工具来方便的管理和访问配置内容。</p>
<p><strong>spring cloud config 分布式配置中心能干嘛？</strong></p>
<ul>
<li>集中式管理配置文件</li>
<li>不同环境，不同配置，动态化的配置更新，分环境部署，比如 /dev /test /prod /beta /release</li>
<li>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</li>
<li>当配置发生变动时，服务不需要重启，即可感知到配置的变化，并应用新的配置</li>
<li>将配置信息以REST接口的形式暴露</li>
</ul>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h4><p>依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--config--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springcloud-config-server</span></span><br><span class="line">  <span class="comment"># 连接远程仓库</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://gitee.com/qyaa/springcloud-config.git</span> <span class="comment">#https的不是SSH的</span></span><br><span class="line"><span class="comment"># 不加这个配置会报Cannot execute request on any known server 这个错：连接Eureka服务端地址不对</span></span><br><span class="line"><span class="comment"># 或者直接注释掉eureka依赖 这里暂时用不到eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>主启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qy.springcloud;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config_Server_3344</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Config_Server_3344.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h4><p>依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!-- actuator 完善监控信息--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--config--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<p><strong>bootstrap.yml</strong> 是系统级别的配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 系统级别的配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config-client</span> <span class="comment"># 需要从git上读取的资源名称，不要后缀</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p><strong>application.yml</strong> 是用户级别的配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户级别的配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Springcloud相关</category>
      </categories>
      <tags>
        <tag>Springcloud</tag>
      </tags>
  </entry>
</search>
